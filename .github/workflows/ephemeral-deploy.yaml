name: Ephemeral Deployment

on:
  workflow_call:
    inputs:
      environmentKeyVaultPrefix:
        required: false
        type: string
        description: "AKS Key vault prefix."
        default: ${{ vars.AZURE_KEYVAULT_PREFIX }}
      repositoryName:
        required: false
        type: string
        description: "GitHub Repository Name."
        default: "${{ github.event.repository.name }}"
      clusterResourceGroup:
        required: false
        type: string
        description: "Azure Resource Group."
        default: "AMU_EphemeralDeployments_RG"
      dockerFilePath:
        required: false
        type: string
        description: "Relative path to Dockerfile."
        default: "."
      dockerImageName:
        required: false
        type: string
        description: "Docker image name."
        default: "${{ github.event.repository.name }}"
      azureResourceLocation:
        required: false
        type: string
        description: "Location of resources in Azure"
        default: "centralus"
      ingressWhitelist:
        required: false
        type: string
        description: "IP address that will be allowed to access the ephemeral deployment"
        default: "207.67.20.252/32"
    secrets:
      azureCredentials:
        required: true
      registryHostName:
        required: true
      registryUserName:
        required: true
      registryPassword:
        required: true
      githubPAT:
        required: true
      JIRA_TOKEN:
        required: true

env:
  githubPrBranch: ${{ github.head_ref }}
  githubPrTitle: ${{ github.event.pull_request.title }}
  githubPrDescription: ${{ github.event.pull_request.body }}

jobs:
  prepare:
    name: Preparation Step
    if: ${{ github.event.action == 'labeled' && github.event.label.name == 'ephemeral-deployment' || github.event_name == 'pull_request' && github.event.action != 'labeled' && contains(github.event.pull_request.labels.*.name, 'ephemeral-deployment') }}
    runs-on: ubuntu-latest
    steps:
      - name: Retrieve Jira ticket ID
        id: jira-ticket
        run: |
          PR_BRANCH=$(echo "${{ env.githubPrBranch }}" | grep -Eo "\b[A-Z][A-Z0-9_]+-[1-9][0-9]*" || true)
          PR_TITLE=$(echo "${{ env.githubPrTitle }}" | grep -Eo "\b[A-Z][A-Z0-9_]+-[1-9][0-9]*" || true)
          PR_DESC=$(echo "${{ env.githubPrDescription }}" | grep -Eo "\b[A-Z][A-Z0-9_]+-[1-9][0-9]*" || true)

          for var in ${PR_BRANCH} ${PR_TITLE} ${PR_DESC}; do JIRA_TICKET_ID=$(echo $var | grep -E ".") && break ; done
          if [ -z "${JIRA_TICKET_ID}" ]; then
            echo "::error A Jira issue key is missing from your branch name, pull request title, and pull request description. Please confirm it is linked properly in the pull request."
            exit 1
          fi
          JIRA_TICKET_ID_LC=$(echo "${JIRA_TICKET_ID}" | tr '[:upper:]' '[:lower:]')

          echo "jiraTicketIdLc=${JIRA_TICKET_ID_LC}" >> $GITHUB_OUTPUT
          echo "jiraTicketId=${JIRA_TICKET_ID}" >> $GITHUB_OUTPUT

      - name: Fix repository name
        id: repository-name
        run: |
          REPOSITORY_NAME="${{ inputs.repositoryName }}"
          REPO_NAME_SHORT=$(echo "${REPOSITORY_NAME:0:21}" | tr '[:upper:]' '[:lower:]' | tr "_" "-")
          echo "repositoryName=${REPO_NAME_SHORT}" >> $GITHUB_OUTPUT

      - name: Get Environment
        id: environment
        shell: bash
        run: |
          DESCRIPTION="${{ env.githubPrDescription }}"
          ENVIRONMENT=$(echo "${DESCRIPTION}" | grep -Eo "\- \[x\] .+ Key Vaults"  | awk -F ' ' '{print $3}' | tr '[:upper:]' '[:lower:]')
          if [ -n "${ENVIRONMENT}" ]; then
            echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          else
            echo "::notice::Unknown environment key vault. Defaulting to development key vault."
            echo "environment=development" >> $GITHUB_OUTPUT
          fi
    outputs:
      environment: ${{ steps.environment.outputs.environment }}
      jiraTicketId: ${{ steps.jira-ticket.outputs.jiraTicketId }}
      jiraTicketIdLc: ${{ steps.jira-ticket.outputs.jiraTicketIdLc }}
      repositoryName: ${{ steps.repository-name.outputs.repositoryName }}

  deploy:
    name: Deploy Azure Container Instance
    if: ${{ github.event.action == 'labeled' && github.event.label.name == 'ephemeral-deployment' || github.event_name == 'pull_request' && github.event.action != 'closed' && github.event.action != 'labeled' && contains(github.event.pull_request.labels.*.name, 'ephemeral-deployment')  }}
    needs: [prepare]
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.prepare.outputs.jiraTicketId }}
      url: ${{ steps.hostname.outputs.hostname }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Generate .env file from Azure Key Vaults
        uses: Andrews-McMeel-Universal/get-envs@v1
        with:
          environment: ${{ needs.prepare.outputs.environment }}
          azurecredentials: ${{ secrets.azureCredentials }}
          environmentKeyVault: ${{ inputs.environmentKeyVaultPrefix }}-${{ needs.prepare.outputs.environment }}

      - name: Set environment variables
        id: env-vars
        shell: bash
        run: |
          ENVIRONMENT_VARIABLES=$(tr "\n" " " < .env)
          TARGET_PORT=$(find . -iname "values.yaml" -exec grep "targetPort: " {} \; | awk -F ': ' '{print $2}' | uniq)

          echo "targetPort=${TARGET_PORT}" >> $GITHUB_OUTPUT
          echo "environmentVariables=${ENVIRONMENT_VARIABLES}" >> $GITHUB_OUTPUT

      - name: Generate build args from Azure Key Vaults
        uses: Andrews-McMeel-Universal/get-envs@v1
        with:
          azurecredentials: ${{ secrets.azureCredentials }}
          environment: ${{ needs.prepare.outputs.environment }}
          environmentKeyVault: ${{ inputs.environmentKeyVaultPrefix }}-${{ needs.prepare.outputs.environment }}
          setBuildArguments: true

      - name: Login to Azure Container Registry
        uses: Azure/docker-login@v1
        with:
          login-server: ${{ secrets.registryHostName }}
          username: ${{ secrets.registryUserName }}
          password: ${{ secrets.registryPassword }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
        with:
          install: true

      - name: Build & Push Docker Image
        run: |
          docker buildx build ${{ env.buildArguments }} -t "${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}:${{ needs.prepare.outputs.jiraTicketId }}" ${{ inputs.dockerFilePath }} --load
          docker push -a "${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}"

      - name: Deploy Azure Container App
        uses: azure/container-apps-deploy-action@v1
        timeout-minutes: 20
        with:
          registryUrl: ${{ secrets.registryHostName }}
          registryUsername: ${{ secrets.registryUserName }}
          registryPassword: ${{ secrets.registryPassword }}
          imageToDeploy: ${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}:${{ needs.prepare.outputs.jiraTicketId }}
          containerAppName: ${{ needs.prepare.outputs.repositoryName }}-${{ needs.prepare.outputs.jiraTicketIdLc }}
          resourceGroup: ${{ inputs.clusterResourceGroup }}
          targetPort: ${{ steps.env-vars.outputs.targetPort }}
          location: ${{ inputs.azureResourceLocation }}
          environmentVariables: ${{ steps.env-vars.outputs.environmentVariables }}
          ingress: external
          disableTelemetry: true

      - name: Add access restrictions to Container App ingress
        run: |
          az containerapp ingress access-restriction set --action Allow --ip-address "${{ inputs.ingressWhitelist }}" --rule-name allow-range --name "${{ needs.prepare.outputs.repositoryName }}-${{ needs.prepare.outputs.jiraTicketIdLc }}" --resource-group "${{ inputs.clusterResourceGroup }}"

      - name: Get Container App Hostname
        id: hostname
        run: |
          HOSTNAME=$(az containerapp list --query "[?name == '${{ needs.prepare.outputs.repositoryName }}-${{ needs.prepare.outputs.jiraTicketIdLc }}'].properties.configuration.ingress.fqdn" -o tsv)
          echo "hostname=https://${HOSTNAME}" >> $GITHUB_OUTPUT

      - name: Check if app is a Next.js application
        if: contains(steps.env-vars.outputs.environmentVariables, 'BASE_URL')
        id: check-next
        run: |
          echo "next-app=true" >> $GITHUB_OUTPUT

    outputs:
      hostname: ${{ steps.hostname.outputs.hostname }}
      next-app: ${{ steps.check-next.outputs.next-app }}
      targetPort: ${{ steps.env-vars.outputs.targetPort }}

  update-next-deploy:
    name: Update Next.js Container App
    if: ${{ needs.deploy.outputs.next-app == 'true' }}
    needs: [prepare,deploy]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Generate .env file from Azure Key Vaults
        uses: Andrews-McMeel-Universal/get-envs@v1
        with:
          environment: ${{ needs.prepare.outputs.environment }}
          azurecredentials: ${{ secrets.azureCredentials }}
          environmentKeyVault: ${{ inputs.environmentKeyVaultPrefix }}-${{ needs.prepare.outputs.environment }}

      - name: Add B2C Redirect URI
        run: |
          az login --service-principal --username "${{ env.B2C_CLIENT_ID }}" --password "${{ env.B2C_CLIENT_SECRET }}" --tenant "${{ env.B2C_TENANT_NAME }}.onmicrosoft.com" --allow-no-subscriptions
          REDIRECT_URIS=()
          IFS=' ' read -ra REDIRECT_URIS <<< "$(echo "$(az ad app list --query "[?appId == '${{ env.B2C_CLIENT_ID }}'].web.redirectUris" -o tsv | tr "\t" " ")" "${{ needs.deploy.outputs.hostname }}/api/auth/callback/azureb2c" | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          az ad app update --id "${{ env.B2C_CLIENT_ID }}" --web-redirect-uris "${REDIRECT_URIS[@]}"

      - name: Update Next URL variables
        id: next-vars
        run: |
          REPOSITORY_NAME=$(echo "${{ github.event.repository.name }}" | awk -F '_' '{print $1}' | tr -d "-")
          HOSTNAME="${{ needs.deploy.outputs.hostname }}"
          ENVIRONMENT_VARIABLES=""
          BUILDARGS=""

          while IFS= read -r VAR; do
            if echo "${VAR}" | grep -Eq "localhost|${REPOSITORY_NAME}.com";then
              VAR=$(echo "${VAR}" | awk -F '=' '{print $1}' | sed "s|$|=${HOSTNAME}|g")
            fi
            ENVIRONMENT_VARIABLES+="${VAR} "
            BUILDARGS="${BUILDARGS} --build-arg ${VAR}"
          done < <(cat .env)

          echo "environmentVariables=${ENVIRONMENT_VARIABLES}" >> $GITHUB_OUTPUT
          echo "buildArguments=${BUILDARGS}" >> $GITHUB_OUTPUT

      - name: Login to Azure Container Registry
        uses: Azure/docker-login@v1
        with:
          login-server: ${{ secrets.registryHostName }}
          username: ${{ secrets.registryUserName }}
          password: ${{ secrets.registryPassword }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
        with:
          install: true

      - name: Build & Push Docker Image with updated Next.js variables
        run: |
          docker buildx build --no-cache ${{ steps.next-vars.outputs.buildArguments }} -t "${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}:${{ needs.prepare.outputs.jiraTicketId }}" ${{ inputs.dockerFilePath }} --load
          docker push -a "${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}"

      - name: Login via Az module
        uses: azure/login@v1
        with:
          creds: "${{ secrets.azureCredentials }}"

      - name: Deploy Azure Container App with updated Next.js variables
        timeout-minutes: 20
        uses: azure/container-apps-deploy-action@v1
        with:
          registryUrl: ${{ secrets.registryHostName }}
          registryUsername: ${{ secrets.registryUserName }}
          registryPassword: ${{ secrets.registryPassword }}
          imageToDeploy: ${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}:${{ needs.prepare.outputs.jiraTicketId }}
          containerAppName: ${{ needs.prepare.outputs.repositoryName }}-${{ needs.prepare.outputs.jiraTicketIdLc }}
          resourceGroup: ${{ inputs.clusterResourceGroup }}
          targetPort: ${{ needs.deploy.outputs.targetPort }}
          location: ${{ inputs.azureResourceLocation }}
          environmentVariables: ${{ steps.next-vars.outputs.environmentVariables }}
          ingress: external
          disableTelemetry: true

  link-deployment:
    name: Link Deployment in Jira
    needs: [prepare,deploy]
    runs-on: ubuntu-latest
    steps:
      - name: Check if deployment has already been linked
        id: check-jira-comments
        shell: pwsh
        run: |
          $uri = "https://amuniversal.atlassian.net/rest/api/2/issue/${{ needs.prepare.outputs.jiraTicketId }}"
          $username = "amu_deploy@amuniversal.com"
          $token = "${{ secrets.JIRA_TOKEN }}"
          $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $username,$token)))
          $response = Invoke-RestMethod -Headers @{Authorization=("Basic {0}" -f $base64AuthInfo)} -Uri $uri -Method Get
          $comments = $response.fields.comment.comments
          foreach ($comment in $comments) {
              if ($comment.body -match "This ticket has been linked to an ephemeral deployment. The URL is: ${{ needs.deploy.outputs.hostname }}") {
                  Write-Output "comment-found=true" >> $env:GITHUB_OUTPUT
                  break
              }
          }

      - name: Login to Jira
        if: ${{ steps.check-jira-comments.outputs.comment-found != 'true' }}
        uses: atlassian/gajira-login@v3
        env:
          JIRA_BASE_URL: https://amuniversal.atlassian.net
          JIRA_USER_EMAIL: amu_deploy@amuniversal.com
          JIRA_API_TOKEN: ${{ secrets.JIRA_TOKEN }}

      - name: Link ephemeral deployment in Jira ticket
        if: ${{ steps.check-jira-comments.outputs.comment-found != 'true' }}
        uses: atlassian/gajira-comment@v3
        with:
          issue: ${{ needs.prepare.outputs.jiraTicketId }}
          comment: |
            This ticket has been linked to an ephemeral deployment.
            - URL: ${{ needs.deploy.outputs.hostname }}
            - Environment APIs: ${{ needs.prepare.outputs.environment }}

  destroy:
    name: Destroy Azure Container Instance
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'closed' }}
    needs: [prepare]
    runs-on: ubuntu-latest
    steps:
      - name: Generate .env file from Azure Key Vaults
        uses: Andrews-McMeel-Universal/get-envs@v1
        with:
          environment: ${{ needs.prepare.outputs.environment }}
          azurecredentials: ${{ secrets.azureCredentials }}
          environmentKeyVault: ${{ inputs.environmentKeyVaultPrefix }}-${{ needs.prepare.outputs.environment }}

      - name: Delete Azure Resources
        run: |
          az containerapp delete --resource-group ${{ inputs.clusterResourceGroup }} --name ${{ needs.prepare.outputs.repositoryName }}-${{ needs.prepare.outputs.jiraTicketIdLc }} --yes
          az acr repository delete -n ${{ secrets.registryHostName }} --image ${{ inputs.dockerImageName }}:${{ needs.prepare.outputs.jiraTicketId }} --yes

      - name: Remove Azure B2C Redirect URI
        if: ${{ env.NEXT_PUBLIC_BASE_URL || env.BASE_URL || env.NEXTAUTH_URL }}
        run: |
          az login --service-principal --username "${{ env.B2C_CLIENT_ID }}" --password "${{ env.B2C_CLIENT_SECRET }}" --tenant "${{ env.B2C_TENANT_NAME }}.onmicrosoft.com" --allow-no-subscriptions
          REDIRECT_URIS=()
          IFS=' ' read -ra REDIRECT_URIS <<< "$(az ad app list --query "[?appId == '${{ env.B2C_CLIENT_ID }}'].web.redirectUris" -o tsv | tr "\t" " " | sed 's|https://[^ ]*azurecontainerapps.io/api/auth/callback/azureb2c*[^ ] ||g')"
          az ad app update --id "${{ env.B2C_CLIENT_ID }}"  --web-redirect-uris "${REDIRECT_URIS[@]}"

      - name: Delete deployment environment
        uses: strumwolf/delete-deployment-environment@v2
        with:
          token: ${{ secrets.githubPAT }}
          environment: ${{ needs.prepare.outputs.jiraTicketId }}
          ref: ${{ github.ref_name }}
