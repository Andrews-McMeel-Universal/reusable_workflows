on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: "Deploy environment. Can be development, staging, or production."
      environmentKeyVault: 
        required: true
        type: string
        description: "AKS Key vault."
      repositoryName:
        required: true
        type: string
        description: "GitHub Repository Name."
      clusterName: 
        required: true
        type: string
        description: "AKS Cluster name."
      clusterResourceGroup:
        required: true
        type: string
        description: "AKS Cluster Resource Group."
      aksIngressFqdn:
        required: true
        type: string
        description: "FQDN for AKS cluster ingress."
      dnsResourceGroup:
        required: true
        type: string
        description: "DNS Resource Group."
      chartsPath:
        required: true
        type: string
        description: "Relative path to Helm charts."
      dockerFilePath:
        required: true
        type: string
        description: "Relative path to Dockerfile."
      dockerImageName:
        required: true
        type: string
        description: "Docker image name."
      dockerImageTag:
        required: true
        type: string
        description: "Docker image tag."
      maximumReplicas:
        required: false
        type: string
        description: "Maximum number of replicas for the application HPA."
        default: 4
      storageAccountName:
        required: true
        type: string
        description: "Storage Account for application information table."
      appInfoTableName:
        required: true
        type: string
        description: "Application information storage table."
    secrets:
      azureCredentials:
        required: true
      registryUserName:
        required: true
      registryPassword:
        required: true
      storageAccountKey:
        required: true

      
jobs:
  AKS_Deploy:
    runs-on: ubuntu-latest
    continue-on-error: false
    timeout-minutes: 360    
    steps:
      - id: getlatestrelease
        if: ${{ inputs.environment == 'production'}}
        uses: thebritican/fetch-latest-release@v1.0.3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout if Staging or Development deployment.
        if: ${{ inputs.environment != 'production'}}
        uses: actions/checkout@master

      - name: Checkout Latest release if Production deployment.
        if: ${{ inputs.environment == 'production'}}
        uses: actions/checkout@v2
        with: 
          ref: ${{ steps.getlatestrelease.outputs.tag_name }}

      - name: Set env
        id: setenvs
        shell: pwsh
        run: |
          Function Get-Envs {
            param (
                [parameter(Mandatory = $true, ValueFromPipeline = $true)]
                [string]$PathToYaml
            )

              #Check to see if powershell-yaml is installed 
              if (Get-Module -Name powershell-yaml) {
                #It's installed, this would be if you are running locally. 
              }
              else {
                  Write-Host "Installing Powershell-Yaml."
                  Install-Module -Name powershell-yaml -Confirm:$false -Force
              }

              Import-Module powershell-yaml

              Write-Host "Getting configuration from: $PathToYaml."

              $Values = Get-Content $PathToYaml | ConvertFrom-Yaml

              return $Values
          }


          $appEnv= "${{ inputs.environment }}"
          $basePath = Get-Location
          $valuesYamlPath = Join-Path $basePath ${{ inputs.chartsPath }} "values.yaml"
          $appConfig = Get-Envs -PathToYaml $valuesYamlPath
          $chartYamlPath = Join-Path $basePath ${{ inputs.chartsPath }} "Chart.yaml"
          $chartConfig= Get-Envs -PathToYaml $chartYamlPath
          $containerRegistry = $appConfig.image.repository
          $appName = $chartConfig.name
          $appVersion = $chartConfig.appVersion
          $appHealthCheck = $appconfig.deployment.healthCheckPath
          $configMap = $appConfig.deployment.configMap
          $configSecret = $appConfig.deployment.secret
          $ingress = $appConfig.ingress.host
          $domainName = ($ingress.Split('.') | Select-Object -Last 2) -join '.'
          $hostName = $ingress -replace $domainName, ''
          if ($hostName.Length -gt 0) 
              {$hostName = $hostName.Substring(0,$hostName.Length-1) 
              switch ($AppEnv) {
                'development' {$hostName = "development.$hostName"; $ingress = "development.$ingress"}
                'staging' {$hostName = "staging.$hostName"; $ingress = "staging.$ingress"}
                }
              }
          else {
              switch ($AppEnv) {
                'development' {$hostName = "development"; $ingress = "development.$ingress"}
                'staging' {$hostName = "staging"; $ingress = "staging.$ingress"}
                }
              }
          $imagePullSecret = "$appName-pull-secret"
          echo "::set-output name=appName::$appName"
          echo "::set-output name=appVersion::$appVersion"
          echo "::set-output name=appHealthCheck::$appHealthCheck"
          echo "::set-output name=configMap::$configMap"
          echo "::set-output name=configSecret::$configSecret"
          echo "::set-output name=ingress::$ingress"
          echo "::set-output name=domainName::$domainName"
          echo "::set-output name=hostName::$hostName"
          echo "::set-output name=imagePullSecret::$imagePullSecret"
          echo "::set-output name=containerRegistry::$containerRegistry"
 
                      
      - name: Login via Az module
        uses: azure/login@v1
        with:
          creds: '${{ secrets.azureCredentials }}'
          enable-AzPSSession: true

      - name: Get Secrets
        id: getsecrets
        uses: azure/powershell@v1
        with:
          inlineScript: |
            Function Get-EnvSecrets {
              param (
                  $KeyVaultName
              )
                #$secretTable = @{}
                $envSecrets = (Get-AzKeyVaultSecret -VaultName $KeyVaultName  | Where-Object {($_.ContentType -contains 'Env') -or ($_.ContentType -contains 'BuildArg Env')}).Name
                $envSecrets | ForEach-Object {
                    $envName = $_.ToUpper() 
                    $envName = $envName.Replace("-","_")
                    $envSecret = (Get-AzKeyVaultSecret -VaultName $KeyVaultName -Name $_).secretvalue | ConvertFrom-SecureString -AsPlainText
                    $envFileContent = $envName + "=" + $envSecret
                    Add-Content -Path ".env" -Value $envFileContent
                }
                return $kubernetesSecret
              }
            Function Get-BuildArgSecrets {
              param (
                  $KeyVaultName
              )
                $buildSecrets = (Get-AzKeyVaultSecret -VaultName $KeyVaultName  | Where-Object {($_.ContentType -contains 'BuildArg') -or ($_.ContentType -contains 'BuildArg Env')}).Name
                if ($buildSecrets.Count -gt 0) {
                    $buildArgPredicate = ' --build-arg '
                }
                else {
                    return
                }
                $buildSecrets | ForEach-Object {
                    $argName = $_.ToUpper() 
                    $argName = $argName.Replace("-","_")
                    $argSecret = (Get-AzKeyVaultSecret -VaultName $KeyVaultName -Name $_).secretvalue | ConvertFrom-SecureString -AsPlainText
                    $buildArgs = $buildArgs + $buildArgPredicate + $argName + "=" + $argSecret
                }
                return $buildArgs
            }
            Get-EnvSecrets -KeyVaultName "${{ inputs.environmentKeyVault }}"
            Write-Host $k8sSecret
            $buildArguments = Get-BuildArgSecrets -KeyVaultName "${{ inputs.environmentKeyVault }}"

            echo "::set-output name=buildArguments::$buildArguments"
          azPSVersion: "latest"

     
      - name: Login to Azure Container Registry
        uses: Azure/docker-login@v1
        with:
          login-server: ${{ steps.setenvs.outputs.containerRegistry }}
          username: ${{ secrets.registryUserName }}
          password: ${{ secrets.registryPassword }}

      - name: Set target AKS cluster
        uses: Azure/aks-set-context@v1
        with:
          creds: '${{ secrets.azureCredentials }}'
          cluster-name: ${{ inputs.clusterName }}
          resource-group: ${{ inputs.clusterResourceGroup }}
      
      - name: Switch to ${{ inputs.environment }} Namespace
        run: kubectl config set-context --current --namespace=${{ inputs.environment }}

      - name: Apply configMap
        if: ${{ steps.setenvs.outputs.configMap != null }}
        uses: swdotcom/update-and-apply-kubernetes-configs@v1
        with:
          k8-config-file-paths: deployments/k8s/config-${{ inputs.environment }}.yaml

      - name: Add GitHub secrets to k8s
        shell: pwsh
        run: |
          kubectl delete secret ${{ steps.setenvs.outputs.configSecret }}
          kubectl create secret generic ${{ steps.setenvs.outputs.configSecret }} --from-env-file .env
          
      - name: Create or Update Public DNS Record
        uses: azure/powershell@v1
        with:
          inlineScript: |
            $NewRecords = New-AzDnsRecordConfig -Cname ${{ inputs.aksIngressFqdn }};
            New-AzDnsRecordSet -Name "${{ steps.setenvs.outputs.hostName }}" -RecordType CNAME -ZoneName ${{ steps.setenvs.outputs.domainName }} -ResourceGroupName ${{ inputs.dnsResourceGroup }} -Ttl 3600 -DnsRecords $NewRecords -Overwrite;
          azPSVersion: '3.1.0'

      - name: Create k8s Image Pull Secret
        uses: Azure/k8s-create-secret@v1
        with:
          container-registry-url: ${{ steps.setenvs.outputs.containerRegistry }}
          container-registry-username: ${{ secrets.registryUserName  }}
          container-registry-password: ${{ secrets.registryPassword  }}
          secret-name: ${{ steps.setenvs.outputs.imagePullSecret }}

      - name: Build & Push Docker Image
        run: |
          docker build ${{ inputs.dockerFilePath }} ${{ steps.getsecrets.outputs.buildArguments }} -t ${{ steps.setenvs.outputs.containerRegistry  }}/${{ inputs.dockerImageName }}:${{ inputs.dockerImageTag }}
          docker push ${{ steps.setenvs.outputs.containerRegistry }}/${{ inputs.dockerImageName }}:${{ inputs.dockerImageTag }}

      - name: Create valid release-name
        id: generate-release-name
        run: |
          release=${{ steps.setenvs.outputs.appName }}-${{ github.sha }}
          release=${release::53}
          release=$(echo ${release//[!0-9a-zA-Z]/-} | tr '[:upper:]' '[:lower:]' | sed -e 's/^-/z/' -e 's/-$/z/')
          echo ::set-output name=result::$release

      - name: Bake Helm templates for Staging and Development
        if: ${{ inputs.environment != 'production'}}
        uses: azure/k8s-bake@v1
        with:
          renderEngine: 'helm'
          helmChart: ${{ inputs.chartsPath }}
          releaseName: ${{steps.generate-release-name.outputs.result}}
          helm-version: 'latest'
          overrides: |
            image.repository:${{ steps.setenvs.outputs.containerRegistry }}/${{ inputs.dockerImageName }}
            image.tag:${{ inputs.dockerImageTag }}
            ingress.host:${{ steps.setenvs.outputs.ingress }}
            autoscaling.maxReplicas:${{ inputs.maximumReplicas }}
        id: bake

      - name: Bake Helm templates for Production
        if: ${{ inputs.environment == 'production'}}
        uses: azure/k8s-bake@v1
        with:
          renderEngine: 'helm'
          helmChart: ${{ inputs.chartsPath }}
          releaseName: ${{steps.generate-release-name.outputs.result}}
          helm-version: 'latest'
          overrides: |
            image.repository:${{ steps.setenvs.outputs.containerRegistry }}/${{ inputs.dockerImageName }}
            image.tag:${{ inputs.dockerImageTag }}
            ingress.host:${{ steps.setenvs.outputs.ingress }}
        id: bakeproduction

      - name: Deploy to Azure ${{ inputs.environment }}
        if: ${{ inputs.environment != 'production'}}
        uses: Azure/k8s-deploy@v1
        with:
          namespace: ${{ inputs.environment }}
          manifests: ${{ steps.bake.outputs.manifestsBundle }}
          images: |
            ${{ steps.setenvs.outputs.containerRegistry }}/${{ inputs.dockerImageName }}:${{ inputs.dockerImageTag }}
          imagePullSecrets: |
            ${{ steps.setenvs.outputs.imagePullSecret }}

      - name: Deploy to Azure production
        if: ${{ inputs.environment == 'production'}}
        uses: Azure/k8s-deploy@v1
        with:
          namespace: ${{ inputs.environment }}
          manifests: ${{ steps.bakeproduction.outputs.manifestsBundle }}
          images: |
            ${{ steps.setenvs.outputs.containerRegistry }}/${{ inputs.dockerImageName }}:${{ inputs.dockerImageTag }}
          imagePullSecrets: |
            ${{ steps.setenvs.outputs.imagePullSecret }}

      - name: Record deployment information in Azure Storage Table ${{ inputs.appInfoTableName }}
        uses: azure/powershell@v1
        with: 
          inlineScript: |
            Install-Module -Name AzTable -Force
            Import-Module AzTable

            $storageAccountName = "${{ inputs.storageAccountName }}"
            $storageAccountKey = ${{ secrets.storageAccountKey }}
            $appInfoTableName = "${{ inputs.appInfoTableName }}"

            $storageContext = New-AzStorageContext -StorageAccountName $storageAccountName -StorageAccountKey $storageAccountKey

            #Get Storage table
            try {
                $appInfoTable = (Get-AzStorageTable -Name $appInfoTableName -Context $storageContext -ErrorAction Stop).CloudTable 
                }
            catch {
                Write-Error -Message "Error accessing cloud $appInfoTableName table.  Error message was: $_.Exception.Message"
                return
                }
            
            $repoName = "${{ inputs.repositoryName }}"
            $appName = "${{ steps.setenvs.outputs.appName }}"
            $appVersion = "${{ steps.setenvs.outputs.appVersion }}"
            $appEnvironment = "${{ inputs.environment }}"
            $appKeyVault = "${{ inputs.environmentKeyVault }}"
            $appHostName = "${{ steps.setenvs.outputs.hostName }}"
            $appDomainName = "${{ steps.setenvs.outputs.domainName }}"
            $appIngressFqdn = "${{ steps.setenvs.outputs.ingress }}"
            $appHealthCheck = "${{ steps.setenvs.outputs.appHealthCheck }}"
            $appAksIngress = "${{ inputs.aksIngressFqdn }}"
            $appCluster = "${{ inputs.clusterName }}"
            $appClusterResouceGroup = "${{ inputs.clusterResourceGroup }}"
            $appConfigSecret = "${{ steps.setenvs.outputs.configSecret }}"
            $appConfigMap = "${{ steps.setenvs.outputs.configMap }}"
            $appDeployDate = Get-Date

            Add-AzTableRow `
                -Table $appInfoTable `
                -partitionKey $repoName `
                -RowKey $appEnvironment `
                -property @{"ApplicationName"="$appName";"Version"="$appVersion";"KeyVault"="$appKeyVault";"HostName"="$appHostName";"DomainName"="$appDomainName";"IngressFqdn"="$appIngressFqdn";"HealthCheckPath"="$appHealthCheck";"AksIngress"="$appAksIngress"; `
                            "Cluster"="$appCluster";"ClusterResourceGroup"="$appClusterResouceGroup";"ConfigSecret"="$appConfigSecret";"ConfigMap"="$appConfigMap";"LastDeploy"="$appDeployDate"} `
                -UpdateExisting | Out-Null

          azPSVersion: "latest"


