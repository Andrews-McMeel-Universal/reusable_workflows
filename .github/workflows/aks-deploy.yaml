name: AKS Deployment

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: "Deploy Environment.  This is used to pull in and set the github environment. Can be development, staging, or production."
      environmentKeyVault:
        required: false
        type: string
        description: "AKS Key vault."
      chartsPath:
        required: false
        type: string
        description: "Relative path to Helm charts."
        default: "./deployments/charts"
      dockerFilePath:
        required: false
        type: string
        description: "Relative path to Dockerfile."
        default: "."
      maximumReplicas:
        required: false
        type: string
        description: "Maximum number of replicas for the application HPA."
        default: ${{ vars.KUBERNETES_MAXIMUM_REPLICAS || '30' }}
      deploymentTimeout:
        required: false
        type: number
        description: "Timeout for GitHub deployments"
        default: 20
      webAuthentication:
        required: false
        type: string
        description: "Enable web authentication"
        default: "false"
      ingressWhitelist:
        required: false
        type: string
        description: "IPs to include in the application whitelist"
        default: ${{ vars.KUBERNETES_INGRESS_WHITELIST || '0.0.0.0/0' }}
      adminIngressWhitelist:
        required: false
        type: string
        description: "IPs to include in the Admin application whitelist"
        default: ${{ vars.KUBERNETES_ADMIN_INGRESS_WHITELIST || '207.67.20.252' }}
      environmentIngress:
        required: false
        type: string
        description: "Use environment in Kubernetes ingress"
        default: "true"
      serviceIngressWhitelist:
        required: false
        type: string
        description: "IPs to include in the service whitelist"
        default: ${{ vars.KUBERNETES_SERVICE_INGRESS_WHITELIST }}
      environmentNamespace:
        required: false
        type: boolean
        description: "Use environment as Kubernetes namespace"
        default: true
      checkoutRef:
        required: false
        type: string
        description: "The branch, tag or SHA to checkout"
        default: ${{ github.ref }}
      githubRunner:
        required: false
        type: string
        description: "The type of runner to use"
        default: ${{ vars.CUSTOM_GITHUB_RUNNER || 'ubuntu-latest' }}
      deploymentWebhook:
        required: false
        type: string
        description: "The webhook URL for the deployment status"
        default: ${{ vars.MSTEAMS_DEPLOYMENT_WEBHOOK }}
      checkoutSubmodules:
        required: false
        type: string
        description: "Check out submodules"
        default: ${{ vars.GIT_CHECKOUT_SUBMODULES }}
      publishSentryRelease:
        required: false
        type: string
        description: "Publish Sentry release"
        default: ${{ vars.PUBLISH_SENTRY_RELEASE || 'true' }}
      haIngress:
        required: false
        type: string
        description: "Enable high availability hostname for ingress (ingress with datacenter location)"
        default: ${{ vars.HA_INGRESS || 'false' }}
      envEncryptionSecret:
        required: false
        type: string
        default: ${{ vars.ENV_ENCRYPTION_SECRET }}
      
      blueGreenDeployment:
        required: false
        type: string
        description: "Enable blue/green deployment strategy"
        default: ${{ vars.BLUE_GREEN_DEPLOYMENT || 'false' }}
      bunnyCdnDomain:
        required: false
        type: string
        description: "Bunny CDN Domain. Set to the domain of your Bunny CDN."
        default: ${{ vars.BUNNY_CDN_DOMAIN }}
      updateBunnyCdnOrigin:
        required: false
        type: string
        description: "Enable updating Bunny CDN pull zone origin after deployment"
        default: ${{ vars.UPDATE_BUNNY_CDN_ORIGIN || 'false' }}
    secrets:
      azureClusterName:
        required: true
      azureCredentials:
        required: true
      registryHostName:
        required: true
      registryUserName:
        required: true
      registryPassword:
        required: true
      storageAccountKey:
        required: true
      webAuthenticationPassword:
        required: false
      webAuthenticationUsername:
        required: false
      PAT_ACTION_CI:
        required: false
      sentryAuthToken:
        required: false
      bunnyCdnApiKey:
        required: false

jobs:
  build:
    name: Build Docker Image
    runs-on: ${{ inputs.githubRunner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkoutRef }}
          submodules: ${{ inputs.checkoutSubmodules }}
          token: ${{ secrets.PAT_ACTION_CI || github.token }}

      - name: Install PowerShell modules for YAML processing
        shell: pwsh
        run: |
          Install-Module -Name powershell-yaml -Force

      - name: Install PowerShell modules for Accessing Azure Table Storage
        if: inputs.blueGreenDeployment == 'true' && inputs.environment == 'production'
        shell: pwsh
        run: |
          Install-Module -Name AzTable,Az.Storage,Az.Resources -Force

      - name: Get Blue/Green Deployment Info
        id: bg-deployment
        if: inputs.blueGreenDeployment == 'true' && inputs.environment == 'production'
        shell: pwsh
        env:
          storageAccountName: amucloudapps
          appInfoTableName: DeployedApplications
          repositoryName: ${{ github.event.repository.name }}
          environment: ${{ inputs.environment }}
        run: |
          # Get Blue/Green Deployment Info
          $storageAccountKey = ${{ secrets.storageAccountKey }}
          $storageContext = New-AzStorageContext -StorageAccountName ${env:storageAccountName} -StorageAccountKey $storageAccountKey

          #Get Storage table
          try {
              $appInfoTable = (Get-AzStorageTable -Name ${env:appInfoTableName} -Context $storageContext -ErrorAction Stop).CloudTable
              }
          catch {
              Write-Error -Message "Error accessing cloud ${env:appInfoTableName} table.  Error message was: $_.Exception.Message"
              return
          }

          $aksIngress = (Get-AzTableRow -Table $appInfoTable -partitionKey ${env:repositoryName} -RowKey ${env:environment} -SelectColumn "AksIngress").AksIngress

          if ($aksIngress -match "-green") {
              $activeDeployment = "green"
              $inactiveDeployment = "blue"
          }
          else {
              $activeDeployment = "blue"
              $inactiveDeployment = "green"
          }
          Write-Output "activeDeployment=$activeDeployment"
          Write-Output "activeDeployment=$activeDeployment" >> $env:GITHUB_ENV
          Write-Output "inactiveDeployment=$inactiveDeployment"
          Write-Output "inactiveDeployment=$inactiveDeployment" >> $env:GITHUB_ENV

      - name: Login via Az module
        if: inputs.haIngress == 'true'
        uses: azure/login@v2
        with:
          creds: "${{ secrets.azureCredentials }}"

      - name: Get AKS cluster info
        id: aks-info
        shell: bash
        run: |
          # Get AKS cluster info

          HA_INGRESS="${{ inputs.haIngress }}"
          if [ "$HA_INGRESS" = "true" ]; then
            AKS_LOCATION=$(az aks list --query "[?name == '${{ secrets.azureClusterName }}'].location" -o tsv | tr '[:upper:]' '[:lower:]' | sort -u)
          else
            AKS_LOCATION="centralus"
          fi
          echo "datacenterLocation=${AKS_LOCATION}" >> $GITHUB_ENV

      - name: Extract Helm values
        id: setenvs
        shell: pwsh
        env:
          appEnvironment: ${{ inputs.environment }}
          haIngress: ${{ inputs.haIngress }}
          chartsPath: ./deployments/charts
          datacenterLocation: ${{ env.datacenterLocation }}
          blueGreenDeployment: ${{ inputs.blueGreenDeployment }}
          inactiveDeployment: ${{ env.inactiveDeployment }}
        run: |
          # Extract Helm values

          # Get charts path
          $basePath = Get-Location
          Write-Output "chartsPath=$chartsPath" >> $env:GITHUB_ENV
          Write-Output "Using charts path: $chartsPath"
          
          $valuesYamlPath = Join-Path $basePath $env:chartsPath "values.yaml"
          $appConfig = Get-Content $valuesYamlPath | ConvertFrom-Yaml
          $chartYamlPath = Join-Path $basePath $env:chartsPath "Chart.yaml"
          $chartConfig = Get-Content $chartYamlPath | ConvertFrom-Yaml

          # Set app name
          $appName = $chartConfig.name
          Write-Output "appName=$appName"
          Write-Output "appName=$appName" >> $env:GITHUB_ENV

          # Set app version
          $appVersion = $chartConfig.appVersion
          Write-Output "appVersion=$appVersion"
          Write-Output "appVersion=$appVersion" >> $env:GITHUB_ENV

          # Set the max replicas based on the environment
          if ($env:appEnvironment -eq "development") {
              $minReplicas = 1
              $maxReplicas = 2
          }
          elseif ($env:appEnvironment -eq "staging") {
              $minReplicas = 2
              $maxReplicas = 4
          }
          else {
              $maxReplicas = $appConfig.autoscaling.maxReplicas
              $minReplicas = $appConfig.autoscaling.minReplicas
          }
          Write-Output "maxReplicas=$maxReplicas"
          Write-Output "maxReplicas=$maxReplicas" >> $env:GITHUB_ENV
          Write-Output "minReplicas=$minReplicas"
          Write-Output "minReplicas=$minReplicas" >> $env:GITHUB_ENV

          # Set image tag
          $release = "$appName-${{ github.sha }}" -replace '(^.{53})(.*$)', '$1'
          $release = ($release -replace '[^-\p{L}\p{Nd}]', '').ToLower() -replace '^-', '' -replace '-$', ''
          Write-Output "release=$release"
          Write-Output "release=$release" >> $env:GITHUB_ENV

          # Set ingress
          $environmentIngress = "${{ inputs.environmentIngress }}" -replace '"', '' -replace "'", ""
          if (($appConfig.schemaVersion -eq "2") -or ($chartConfig.version -ge "2.0.0")) {
              $ingress = ($appConfig.ingress | Where-Object { $_.Name -eq "ingress" }).host
              if (($appConfig.ingress.redirectToWWW -eq $true) -and ($env:appEnvironment -eq "production") -and ($environmentIngress -ne "true")) {
                  $wwwIngress = "true"
              }
          }
          else {
              $ingress = $appConfig.ingress.host
          }

          # Set domain name
          $domainName = ($ingress.Split('.') | Select-Object -Last 2) -join '.'

          # Add environment to ingress
          if ($environmentIngress -ne "false") {
              if ($env:blueGreenDeployment -eq "true" -and $env:appEnvironment -eq "production") {
                  $ingress = "${env:appEnvironment}-${env:inactiveDeployment}.$ingress"
              }
              else {
                  $ingress = "${env:appEnvironment}.$ingress"
              }
          }

          # Add datacenter location to ingress if HA hostname is enabled
          if ($env:haIngress -eq "true") {
              $subDomain = $ingress -replace "$domainName", '' -replace "\.$", ""

              if ($subDomain -match "$env:datacenterLocation") {
                  Write-Output "Datacenter location already present in ingress: $($ingress)"
                  continue
              }

              if ($subDomain -match "\.service") {
                  if ($subDomain -match "services") {
                      $domainName = "services.$domainName"
                  }
                  else {
                      $domainName = "service.$domainName"
                  }
              }

              Write-Output "Adding datacenter location to ingress: $($ingress)"
              if ($subDomain -ne "") {
                  $ingress = "$subDomain.${env:datacenterLocation}.$domainName"
              }
              else {
                  $ingress = "${env:datacenterLocation}.$domainName"
              }
          }

          Write-Output "domainName=$domainName"
          Write-Output "domainName=$domainName" >> $env:GITHUB_ENV
          Write-Output "ingress=$ingress"
          Write-Output "ingress=$ingress" >> $env:GITHUB_ENV
          Write-Output "wwwIngress=$wwwIngress"
          Write-Output "wwwIngress=$wwwIngress" >> $env:GITHUB_ENV

      - name: Generate .env file from Azure Key Vaults
        id: get-envs
        uses: Andrews-McMeel-Universal/get-envs@v1
        with:
          azurecredentials: ${{ secrets.azureCredentials }}
          environment: ${{ inputs.environment }}
          environmentKeyVault: ${{ inputs.environmentKeyVault }}
          contentTypes: BuildArg Env
          buildArgPredicate: ";"

      - name: Insert new line after build arguments
        id: insert-new-line
        shell: bash
        run: |
          # Insert new line after build arguments

          buildArguments=$(echo "${{ steps.get-envs.outputs.buildArguments }}" | sed 's/^ ; //g' | sed 's/; /\n/g')
          echo 'buildArguments<<EOF' >> $GITHUB_ENV
          echo "$buildArguments" >> $GITHUB_ENV
          echo 'EOF' >> $GITHUB_ENV

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v2
        with:
          login-server: ${{ secrets.registryHostName }}
          username: ${{ secrets.registryUserName }}
          password: ${{ secrets.registryPassword }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.registryHostName }}/${{ github.event.repository.name }}
          tags: |
            type=raw,value=${{ github.sha }}-${{ inputs.environment }}
            type=raw,value=${{ inputs.environment }}
            type=raw,value=latest,enable=${{ inputs.environment == 'production' }}
            type=raw,value=stable,enable=${{ inputs.environment == 'production' }}
            type=semver,value=${{ github.event.release.tag_name }},pattern={{version}},enable=${{ github.event.release.tag_name != '' }}
            type=semver,value=${{ github.event.release.tag_name }},pattern={{major}},enable=${{ github.event.release.tag_name != '' }}
          flavor: |
            latest=false

      - name: Enable write access if image has already been deployed
        shell: bash
        env:
          REPOSITORY_NAME: ${{ github.event.repository.name }}
          GITHUB_SHA: ${{ github.sha }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          # Enable write access if image has already been deployed

          REGISTRY_HOSTNAME="${{ secrets.registryHostName }}"

          IMAGE_MANIFEST=$(az acr repository show --name "${REGISTRY_HOSTNAME}" --image "${REPOSITORY_NAME}:${GITHUB_SHA}-${ENVIRONMENT}" --query "digest" -o tsv || echo "")
          if [ -z "${IMAGE_MANIFEST}" ]; then
            echo "Failed to get current image manifest, proceeding with deployment."
          else
            echo "Enabling write access for image manifest."
            az acr repository update --name "${REGISTRY_HOSTNAME}" --image "${REPOSITORY_NAME}@${IMAGE_MANIFEST}" --write-enabled true
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.dockerFilePath }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            ${{ env.buildArguments }}

      - name: Send Failed Deployment report to Teams
        if: failure() && (inputs.environment != 'development')
        uses: jdcargile/ms-teams-notification@v1.4
        with:
          github-token: ${{ github.token }}
          ms-teams-webhook-uri: ${{ inputs.deploymentWebhook }}
          notification-summary: "${{ github.event.release.tag_name != '' && format('{0} ', github.event.release.tag_name) || ' ' }}Failed ${{ inputs.environment }} Deployment"
          notification-color: 17a2b8
          timezone: America/Chicago
          verbose-logging: true
    outputs:
      appName: ${{ env.appName }}
      appVersion: ${{ env.appVersion }}
      ingress: ${{ env.ingress }}
      domainName: ${{ env.domainName }}
      release: ${{ env.release }}
      maxReplicas: ${{ env.maxReplicas }}
      minReplicas: ${{ env.minReplicas }}
      chartsPath: ${{ env.chartsPath }}
      wwwIngress: ${{ env.wwwIngress }}
      inactiveDeployment: ${{ env.inactiveDeployment }}
      datacenterLocation: ${{ env.datacenterLocation }}

  deploy:
    name: AKS Deploy
    needs: [build]
    runs-on: ${{ inputs.githubRunner }}
    environment:
      name: ${{ inputs.environment }}
      url: https://${{ needs.build.outputs.ingress }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkoutRef }}

      - name: Install PowerShell modules for YAML processing
        shell: pwsh
        run: |
          Install-Module -Name powershell-yaml -Force

      - name: Create values override file
        id: values-override
        shell: pwsh
        env:
          environment: ${{ inputs.environment }}
          chartsPath: ${{ inputs.chartsPath }}
          haIngress: ${{ inputs.haIngress }}
          adminIngressWhitelist: ${{ inputs.adminIngressWhitelist }}
          serviceIngressWhitelist: ${{ inputs.serviceIngressWhitelist }}
          datacenterLocation: ${{ needs.build.outputs.datacenterLocation }}
          domainName: ${{ needs.build.outputs.domainName }}
          wwwIngress: ${{ needs.build.outputs.wwwIngress }}
          ingress: ${{ needs.build.outputs.ingress }}
          ingressWhitelist: ${{ inputs.ingressWhitelist }}
          blueGreenDeployment: ${{ inputs.blueGreenDeployment }}
          inactiveDeployment: ${{ needs.build.outputs.inactiveDeployment }}
        run: |
          # Create values override file

          # Get charts path
          $basePath = Get-Location
          Write-Output "Using charts path: $env:chartsPath"
          
          $valuesYamlPath = Join-Path $basePath $env:chartsPath "values.yaml"
          $appConfig = Get-Content $valuesYamlPath | ConvertFrom-Yaml
          $chartYamlPath = Join-Path $basePath $env:chartsPath "Chart.yaml"
          $chartConfig = Get-Content $chartYamlPath | ConvertFrom-Yaml

          $appName = $chartConfig.name
          $appConfig.environment = $env:environment

          $webAuthentication = "${{ inputs.webAuthentication }}" -replace '"', '' -replace "'", ""
          $environmentIngress = "${{ inputs.environmentIngress }}" -replace '"', '' -replace "'", ""
          $clusterIssuer = "letsencrypt-$env:environment"

          $domains = @()
          $updatedIngress = @()
          foreach ($item in $appConfig.ingress) {
              # Set ingress whitelist if not set
              $ipRegex = '^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){2}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/(3[0-2]|[12]?[0-9]))?$'

              $allIPsValid = $true
              $env:ingressWhitelist -split ',' | ForEach-Object {
                  if ($_ -notmatch $ipRegex) {
                      $allIPsValid = $false
                  }
              }

              if (($item.name -ne "admin-ingress") -and (-not $allIPsValid)) {
                  Write-Output "Ingress whitelist not set for $($item.name)"
                  
                  if (($env:ingressWhitelist -eq "service") -or ($item.annotations."nginx.ingress.kubernetes.io/whitelist-source-range" -match "207.67.20.239,40.86.103.124,40.77.105.170")) {
                      # Use service whitelist
                      Write-Output "Overriding ingress whitelist with service whitelist for $($item.name)"
                      $ingressWhitelist = $env:serviceIngressWhitelist
                  }
                  elseif ($item.annotations."nginx.ingress.kubernetes.io/whitelist-source-range") {
                      # Use existing whitelist
                      Write-Output "Using existing ingress whitelist for $($item.name)"
                      $ingressWhitelist = $item.annotations."nginx.ingress.kubernetes.io/whitelist-source-range"
                  } 
                  else {
                      # Default to 0.0.0.0/0
                      Write-Output "Defaulting to 0.0.0.0/0 ingress whitelist for $($item.name)"
                      $ingressWhitelist = "0.0.0.0/0"
                  }
              }
              elseif ($item.privateIngress -eq "true") {
                  Write-Output "Private ingress is enabled, setting ingress whitelist to service whitelist for $($item.name)"
                  if (($env:adminIngressWhitelist -ne "207.67.20.252") -or ($env:adminIngressWhitelist -ne "")) {
                      $ingressWhitelist = $env:adminIngressWhitelist
                  }
                  else {
                      $ingressWhitelist = $env:serviceIngressWhitelist
                  }
              }
              elseif ($webAuthentication -eq "true") {
                  Write-Output "Web authentication is enabled, setting ingress whitelist to '0.0.0.0/0' for $($item.name)"
                  $ingressWhitelist = "0.0.0.0/0"
              }

              # Add datacenter location to ingress if HA hostname is enabled
              if ($env:haIngress -eq "true") {
                  $subDomain = $item.host -replace "$env:domainName", '' -replace "\.$", ""

                  if ($subDomain -match $env:datacenterLocation) {
                      Write-Output "Datacenter location already present in $($item.name): $($item.host)"
                      continue
                  }

                  if ($subDomain -match "\.service") {
                      if ($subDomain -match "services") {
                          $domainName = "services.${env:domainName}"
                      }
                      else {
                          $domainName = "service.${env:domainName}"
                      }
                  }

                  Write-Output "Adding datacenter location to $($item.name): $($item.host)"
                  if ($subDomain -ne "") {
                      $item.host = "$subDomain.${env:datacenterLocation}.$domainName"
                  }
                  else {
                      $item.host = "${env:datacenterLocation}.$domainName"
                  }
              }

              # Add environment to ingress
              if ($environmentIngress -ne "false") {
                  if ($env:blueGreenDeployment -eq "true" -and $env:environment -eq "production") {
                      $item.host = "${env:environment}-${env:inactiveDeployment}.$($item.host)"
                      Write-Output "Adding environment and inactive deployment to $($item.name): $($item.host)"
                  }
                  else {
                      $item.host = "${env:environment}.$($item.host)"
                      Write-Output "Adding environment to $($item.name): $($item.host)"
                  }
              }

              # Add ingressClassName to ingress
              if ($env:blueGreenDeployment -eq "true" -and $env:environment -eq "production") {
                  # Set ingress class name
                  $item.ingressClassName = "nginx-${env:environment}-${env:inactiveDeployment}"

                  # Add cluster issuer annotation
                  $item.annotations."cert-manager.io/cluster-issuer" = "letsencrypt-${env:environment}-${env:inactiveDeployment}"
              }
              else {
                  # Set ingress class name
                  $item.ingressClassName = "nginx-${env:environment}"

                  # Add cluster issuer annotation
                  $item.annotations."cert-manager.io/cluster-issuer" = "letsencrypt-${env:environment}"
              }

              # Reset annotations
              if ($null -eq $item.annotations) {
                  $item.annotations = @{}
              }


              # Add whitelist annotation
              $item.annotations."nginx.ingress.kubernetes.io/limit-whitelist" = "$env:adminIngressWhitelist"

              if ($item.name -eq "ingress") {
                  # Add WWW to ingress
                  if (($item.redirectToWWW -eq $true) -and ($env:environment -eq "production") -and ($environmentIngress -ne "true")) {
                      # Add www redirect ingress
                      $updatedIngress += [PSCustomObject]@{
                          name = "wwwredirect"
                          host = $item.host
                          path = "/(.*)"
                          ingressClassName = $item.ingressClassName
                          annotations = @{
                              "nginx.ingress.kubernetes.io/rewrite-target" = "https://www.$($item.host)/$1"
                              "cert-manager.io/cluster-issuer" = $clusterIssuer
                          }
                      }

                      Write-Output "Adding www to $($item.name) host"
                      $item.host = "www.$($item.host)"
                  }

                  # Set ingress host to primary domain variable
                  $dnsPrimaryDomain = $item.host -replace "$env:domainName", '' -replace "\.$", ""

                  # Add webAuthentication to main ingress
                  if ($webAuthentication -eq "true") {
                      Write-Output "Adding basic auth to $($item.name)"
                      $item.annotations."nginx.ingress.kubernetes.io/auth-type"="basic"
                      $item.annotations."nginx.ingress.kubernetes.io/auth-secret"="$appName-basic-auth"
                      $item.annotations."nginx.ingress.kubernetes.io/auth-realm"="Authentication Required"
                  }
              }
              elseif ($item.name -eq "admin-ingress") {
                  if (($env:adminIngressWhitelist -ne "207.67.20.252") -or ($env:adminIngressWhitelist -ne "")) {
                      $item.annotations."nginx.ingress.kubernetes.io/whitelist-source-range" = $env:adminIngressWhitelist
                  }
                  else {
                      $item.annotations."nginx.ingress.kubernetes.io/whitelist-source-range" = "207.67.20.252"
                  }
                  Write-Output "Setting ingress whitelist for $($item.name) to: $($item.annotations."nginx.ingress.kubernetes.io/whitelist-source-range")"
              }

              # Add www redirect to ingress
              if (($item.name -ne "ingress") -and ("$env:wwwIngress" -eq "true") -and ($item.redirectToWWW -ne $false) -and ($item.host -match "$env:ingress") -or (($item.name -ne "ingress") -and ($item.redirectToWWW -eq $true))) {
                  Write-Output "Adding www to $($item.name) host"
                  $item.host = "www.$($item.host)"
              }

              # Ensure the ingress whitelist is set for all other ingresses except admin-ingress
              if ($item.name -ne "admin-ingress") {
                  # Add ingressWhitelist to ingress
                  Write-Output "Setting ingress whitelist for $($item.name) to: $ingressWhitelist"
                  $item.annotations."nginx.ingress.kubernetes.io/whitelist-source-range" = $ingressWhitelist
              }

              # Remove annotations if empty
              if ($item.annotations.Count -eq 0) {
                  $item.Remove("annotations")
              }

              $updatedIngress += [PSCustomObject]@{
                  name = $item.name
                  host = $item.host
                  path = $item.path
                  ingressClassName = $item.ingressClassName
                  annotations = $item.annotations
              }

              # Add hostnames to domains variable
              if ($item.host -replace "$env:domainName", '' -replace "\.$", "" -eq "" -or $item.host -replace "$env:domainName", '' -replace "\.$", "" -eq " " -or $item.host -replace "$env:domainName", '' -replace "\.$", "" -eq $null) {
                  Write-Output "Skipping adding empty hostname $($item.host) to domains list"
                  continue
              }
              $domains += $item.host -replace "$env:domainName", '' -replace "\.$", ""
              Write-Output "Adding $($item.host) to domains list"
          }

          # Ensure ingress is an array
          $appConfig.ingress = @($updatedIngress)

          # Ensure the service annotations are set properly
          if ($appConfig.service) {
              # Ensure the service has annotations
              if ($null -eq $appConfig.service.annotations) {
                  $appConfig.service.annotations = @{}
              }
              # Ensure the service has the correct internal load balancer annotation
              if (-not $appConfig.service.annotations."service.beta.kubernetes.io/azure-load-balancer-internal") {
                  Write-Output "Setting service.beta.kubernetes.io/azure-load-balancer-internal annotation for the service"
                  $appConfig.service.annotations."service.beta.kubernetes.io/azure-load-balancer-internal" = "true"
              }
          }
          else {
              Write-Output "No service found in values.yaml to set internal load balancer annotation."
          }

          # Remove www redirect ingress if not production
          if ($env:environment -ne "production") {
              $appConfig.ingress = $appConfig.ingress | Where-Object { $_.name -ne "wwwredirect" }
          }

          # Store keys to remove in a separate list
          $keysToRemove = @()

          foreach ($key in $appConfig.Keys) {
              if (($key -ne "ingress") -and ($key -ne "$env:environment") -and ($key -ne "service")) {
                  $keysToRemove += $key
              }
          }

          # Remove keys from the original collection
          foreach ($key in $keysToRemove) {
              $appConfig.Remove($key)
          }

          # Write to file
          $appConfig | ConvertTo-Yaml | ForEach-Object { $_ -replace "  name:", "- name:" } | Out-File -FilePath "./values-override.yaml"

          # Output file content
          Write-Output "---"
          Write-Output "# Source: values-override.yaml"
          Get-Content "./values-override.yaml"

          # Set domains
          Write-Output "---"
          Write-Output "# Source: DNS domains"
          Write-Output "domains=$domains"
          Write-Output "domains=$domains" >> $env:GITHUB_OUTPUT
          Write-Output "dnsPrimaryDomain=$dnsPrimaryDomain"
          Write-Output "dnsPrimaryDomain=$dnsPrimaryDomain" >> $env:GITHUB_OUTPUT

      - name: Bake Helm Templates
        id: bake
        uses: azure/k8s-bake@v3
        with:
          renderEngine: "helm"
          helmChart: ${{ inputs.chartsPath }}
          releaseName: ${{ needs.build.outputs.release }}
          helm-version: "v3.19.2"
          overrideFiles: ./values-override.yaml
          overrides: |
            deployment.image.repository:${{ secrets.registryHostName }}/${{ github.event.repository.name }}
            deployment.image.tag:${{ github.sha }}-${{ inputs.environment }}
            image.repository:${{ secrets.registryHostName }}/${{ github.event.repository.name }}
            image.tag:${{ github.sha }}-${{ inputs.environment }}
            autoscaling.maxReplicas:${{ needs.build.outputs.maxReplicas }}
            autoscaling.minReplicas:${{ needs.build.outputs.minReplicas }}

      - name: Generate .env file from Azure Key Vaults
        uses: Andrews-McMeel-Universal/get-envs@v1
        with:
          azurecredentials: ${{ secrets.azureCredentials }}
          environment: ${{ inputs.environment }}
          environmentKeyVault: ${{ inputs.environmentKeyVault }}

      - name: Get AKS cluster resource group
        id: aks-resource-group
        shell: bash
        run: |
          # Get AKS cluster resource group

          AKS_RESOURCE_GROUP=$(az aks list --query "[?name == '${{ secrets.azureClusterName }}'].resourceGroup" -o tsv)
          echo "AKS_RESOURCE_GROUP=${AKS_RESOURCE_GROUP}" >> $GITHUB_OUTPUT

      - name: Set target AKS cluster
        uses: azure/aks-set-context@v4
        with:
          cluster-name: ${{ secrets.azureClusterName }}
          resource-group: ${{ steps.aks-resource-group.outputs.AKS_RESOURCE_GROUP }}

      - name: Switch Kubernetes Namespace
        id: namespace
        shell: bash
        env:
          ENVIRONMENT_NAMESPACE: ${{ inputs.environmentNamespace }}
          ENVIRONMENT: ${{ inputs.environment }}
          BLUE_GREEN_DEPLOYMENT: ${{ inputs.blueGreenDeployment }}
          INACTIVE_DEPLOYMENT: ${{ needs.build.outputs.inactiveDeployment }}
        run: |
          # Switch Kubernetes Namespace
          if [ $ENVIRONMENT_NAMESPACE == "true" ]; then
            if [ $BLUE_GREEN_DEPLOYMENT == "true" ] && [ $ENVIRONMENT == "production" ]; then
              ENVIRONMENT="${ENVIRONMENT}-${INACTIVE_DEPLOYMENT}"
            fi
            kubectl config set-context --current --namespace="${ENVIRONMENT}"
            echo "namespace=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          else
            echo "namespace=default" >> $GITHUB_OUTPUT
          fi

      - name: Update .env Kubernetes secret
        shell: bash
        env:
          APP_NAME: ${{ needs.build.outputs.appName }}
        run: |
          # Update .env Kubernetes secret

          if kubectl get secret "${APP_NAME}-config-secret" > /dev/null 2>&1; then
              kubectl delete secret "${APP_NAME}-config-secret"
          fi
          kubectl create secret generic "${APP_NAME}-config-secret" --validate='warn' --from-env-file ${{ github.workspace }}/.env

      - name: Update basic web authentication Kubernetes secret
        shell: bash
        env:
          WEB_AUTHENTICATION: ${{ inputs.webAuthentication }}
          APP_NAME: ${{ needs.build.outputs.appName }}
        run: |
          # Update basic web authentication Kubernetes secret
          WEB_AUTHENTICATION_USERNAME="${{ secrets.webAuthenticationUsername }}"
          WEB_AUTHENTICATION_PASSWORD="${{ secrets.webAuthenticationPassword }}"

          if [[ "${WEB_AUTHENTICATION}" == "true" ]]; then
              if [[ -z "${WEB_AUTHENTICATION_USERNAME}" ]] || [[ -z "${WEB_AUTHENTICATION_PASSWORD}" ]]; then
                  echo "::error::Please make sure the 'webAuthenticationUsername' and 'webAuthenticationPassword' GitHub environment secrets are set correctly."
                  exit 1
              fi
          
              if kubectl get secret "${APP_NAME}-basic-auth" > /dev/null 2>&1; then
                  kubectl delete secret "${APP_NAME}-basic-auth"
              fi
              htpasswd -cb auth "${WEB_AUTHENTICATION_USERNAME}" "${WEB_AUTHENTICATION_PASSWORD}"
              kubectl create secret generic "${APP_NAME}-basic-auth" --from-file=auth
          fi

      - name: Create K8s Image Pull Secret
        uses: azure/k8s-create-secret@v5
        with:
          container-registry-url: ${{ secrets.registryHostName }}
          container-registry-username: ${{ secrets.registryUserName  }}
          container-registry-password: ${{ secrets.registryPassword  }}
          secret-name: "${{ needs.build.outputs.appName }}-pull-secret"
          namespace: ${{ steps.namespace.outputs.namespace }}

      - name: Get previous image tag used in deployment
        id: get-previous-image
        shell: bash
        env:
          APP_NAME: ${{ needs.build.outputs.appName }}
          NAMESPACE: ${{ steps.namespace.outputs.namespace }}
        run: |
          # Get previous image tag used in deployment

          PREVIOUS_IMAGE=$(kubectl get deployment "${APP_NAME}" -n "${NAMESPACE}" -o=jsonpath='{$.spec.template.spec.containers[:1].image}' | awk -F '/' '{print $2}' || echo "")
          if [ -z "${PREVIOUS_IMAGE}" ]; then
            echo "No previous image found, proceeding with deployment"
          else
            echo "Previous image found: ${PREVIOUS_IMAGE}"
          fi
          echo "previousImage=${PREVIOUS_IMAGE}" >> $GITHUB_OUTPUT

      - name: Deploy to Azure Kubernetes Service
        timeout-minutes: ${{ inputs.deploymentTimeout }}
        uses: azure/k8s-deploy@v5
        with:
          namespace: ${{ steps.namespace.outputs.namespace }}
          manifests: ${{ steps.bake.outputs.manifestsBundle }}
          images: |
            "${{ secrets.registryHostName }}/${{ github.event.repository.name }}:${{ github.sha }}-${{ inputs.environment }}"
          imagepullsecrets: |
            "${{ needs.build.outputs.appName }}-pull-secret"
          pull-images: false

      - name: Unlock and untag previous ACR image
        if: ${{ steps.get-previous-image.outputs.previousImage != '' }}
        shell: bash
        env:
          DEPLOYMENT_PREVIOUS_IMAGE: ${{ steps.get-previous-image.outputs.previousImage }}
          REPOSITORY_NAME: ${{ github.event.repository.name }}
          GITHUB_SHA: ${{ github.sha }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          # Unlock and untag previous ACR image

          REGISTRY_HOSTNAME="${{ secrets.registryHostName }}"

          PREVIOUS_MANIFEST=$(az acr repository show --name "${REGISTRY_HOSTNAME}" --image "${DEPLOYMENT_PREVIOUS_IMAGE}" --query "digest" -o tsv || true)
          if [[ -n "$PREVIOUS_MANIFEST" ]] && [[ "${DEPLOYMENT_PREVIOUS_IMAGE}" != "${REPOSITORY_NAME}:${GITHUB_SHA}-${ENVIRONMENT}" ]]; then
            echo "Unlocking previous manifest: ${PREVIOUS_MANIFEST}"
            az acr repository update --name "${REGISTRY_HOSTNAME}" --image "${REPOSITORY_NAME}@${PREVIOUS_MANIFEST}" --delete-enabled true --write-enabled true
            while read -r TAG; do
              SEMVER_REGEX="^[0-9]+\.[0-9]+\.[0-9]+$"
              if [[ ! "${TAG}" =~ $SEMVER_REGEX ]]; then
                echo "Untagging ${REPOSITORY_NAME}:${TAG}"
                az acr repository untag --name "${REGISTRY_HOSTNAME}" --image "${REPOSITORY_NAME}:${TAG}"
              else
                echo "Skipping untagging ${REPOSITORY_NAME}:${TAG}"
              fi
            done < <(az acr repository show --name "${REGISTRY_HOSTNAME}" --image "${REPOSITORY_NAME}@${PREVIOUS_MANIFEST}" --query "tags" -o tsv)
          elif [[ "${DEPLOYMENT_PREVIOUS_IMAGE}" == "${REPOSITORY_NAME}:${GITHUB_SHA}-${ENVIRONMENT}" ]]; then
            echo "Deployment image is the same as the current image. Skipping unlocking."
          else
            echo "Previous manifest could not be found. Skipping unlocking."
          fi

      - name: Disable delete access for newly deployed image
        shell: bash
        env:
          REPOSITORY_NAME: ${{ github.event.repository.name }}
          GITHUB_SHA: ${{ github.sha }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          # Disable delete access for newly deployed image

          REGISTRY_HOSTNAME="${{ secrets.registryHostName }}"

          IMAGE_MANIFEST=$(az acr repository show --name "${REGISTRY_HOSTNAME}" --image "${REPOSITORY_NAME}:${GITHUB_SHA}-${ENVIRONMENT}" --query "digest" -o tsv)
          if [ -z "${IMAGE_MANIFEST}" ]; then
            echo "Failed to get current image manifest"
          fi
          az acr repository update --name "${REGISTRY_HOSTNAME}" --image "${REPOSITORY_NAME}@${IMAGE_MANIFEST}" --delete-enabled false

      - name: Create or Update Public DNS Record
        id: dns
        shell: bash
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          ENVIRONMENT_NAMESPACE: ${{ inputs.environmentNamespace }}
          BLUE_GREEN_DEPLOYMENT: ${{ inputs.blueGreenDeployment }}
          BLUE_GREEN_INACTIVE_DEPLOYMENT: ${{ needs.build.outputs.inactiveDeployment }}
          INGRESS_DOMAIN_NAME: ${{ needs.build.outputs.domainName }}
          INGRESS_DOMAINS: ${{ steps.values-override.outputs.domains }}
          DATACENTER_LOCATION: ${{ needs.build.outputs.datacenterLocation || 'centralus' }}
        run: |
          # Create or Update Public DNS Record

          # Set AKS cluster ingress
          AKS_CLUSTER_NAME="${{ secrets.azureClusterName }}"

          # Add environment suffixes if applicable
          if [ "${ENVIRONMENT_NAMESPACE}" == "true" ]; then
            INGRESS="${AKS_CLUSTER_NAME}-${ENVIRONMENT}"
          else
            INGRESS="${AKS_CLUSTER_NAME}"
          fi

          # Set AKS ingress FQDN
          if [ "${BLUE_GREEN_DEPLOYMENT}" == "true" ] && [ "${ENVIRONMENT}" == "production" ]; then
            AKS_INGRESS="${INGRESS}-${BLUE_GREEN_INACTIVE_DEPLOYMENT}-ingress.${DATACENTER_LOCATION}.cloudapp.azure.com."
            DNS_RECORD_TTL=600
          else
            AKS_INGRESS="${INGRESS}-ingress.${DATACENTER_LOCATION}.cloudapp.azure.com."
            DNS_RECORD_TTL=3600
          fi
          echo "aksIngress=${AKS_INGRESS}"
          echo "aksIngress=${AKS_INGRESS}" >> "$GITHUB_OUTPUT"

          # Populate INGRESSES array safely
          mapfile -t INGRESSES < <(echo "${INGRESS_DOMAINS}" | sed "s/ $//g" | tr ' ' '\n' | sort -u)

          # Check if INGRESSES is empty
          if [ "${#INGRESSES[@]}" -eq 0 ]; then
            echo "No domains found in values-override.yaml"
            exit 1
          fi

          # Update DNS record
          for INGRESS in "${INGRESSES[@]}"; do
            echo "Updating DNS record for ${INGRESS} to ${AKS_INGRESS}"
            az network dns record-set cname set-record \
              --resource-group "AMU_DNS_RG" \
              --zone-name "${INGRESS_DOMAIN_NAME}" \
              --record-set-name "${INGRESS}" \
              --cname "${AKS_INGRESS}" \
              --ttl ${DNS_RECORD_TTL}

            # Update root domain for blue-green deployments in production
            if [ "${BLUE_GREEN_DEPLOYMENT}" == "true" ] && [ "${ENVIRONMENT}" == "production" ]; then
              ROOT_INGRESS="${INGRESS/-${BLUE_GREEN_INACTIVE_DEPLOYMENT}/}"
              echo "Updating DNS record for ${ROOT_INGRESS} to ${AKS_INGRESS}"
              az network dns record-set cname set-record \
                --resource-group "AMU_DNS_RG" \
                --zone-name "${INGRESS_DOMAIN_NAME}" \
                --record-set-name "${ROOT_INGRESS}" \
                --cname "${AKS_INGRESS}" \
                --ttl ${DNS_RECORD_TTL}
            fi
          done

      - name: Update Bunny CDN origin URL
        if: inputs.bunnyCdnDomain != '' && inputs.blueGreenDeployment == 'true' && inputs.environment == 'production'
        shell: pwsh
        env:
          bunnyCdnDomain: ${{ inputs.bunnyCdnDomain }}
          environment: ${{ inputs.environment }}
          inactiveDeployment: ${{ needs.build.outputs.inactiveDeployment }}
          dnsPrimaryDomain: ${{ steps.values-override.outputs.dnsPrimaryDomain }}
          ingressDomainName: ${{ needs.build.outputs.domainName }}
        run: |
          # Update Bunny CDN origin URL
          $bunnyCdnApiKey = "${{ secrets.bunnyCdnApiKey }}"

          # Set headers
          $headers = @{
              "AccessKey" = "$bunnyCdnApiKey"
              "accept" = "application/json"
              "content-type" = "application/json"
          }

          # Get Pull Zone ID
          $uri = "https://api.bunny.net/pullzone?page=0&perPage=1000&search=${env:bunnyCdnDomain}&includeCertificate=false"
          $bunnyCdnPullZoneId = (Invoke-WebRequest -Headers $headers -Uri $uri -Method 'GET' | ConvertFrom-Json).Items.Id

          # Update origin URL
          Write-Output "Updating Bunny CDN origin URL to: ${originUrl}"
          $originUrl = "https://${env:dnsPrimaryDomain}.${env:ingressDomainName}"
          $body = @{
              "PreloadingScreenShowOnFirstVisit" = "true"
              "OriginUrl" = "$originUrl"
          } | ConvertTo-Json
          $uri = "https://api.bunny.net/pullzone/${bunnyCdnPullZoneId}"
          $response = (Invoke-WebRequest -Headers $headers -Uri $uri -Method 'POST' -Body $body | ConvertFrom-Json)

          if ($response.OriginUrl -match "$originUrl") {
              Write-Output "Bunny CDN origin URL was updated successfully"
          }
          else {
              throw "Bunny CDN origin URL update response did not contain the expected origin URL."
              Write-Output "Output: $response"
              exit 1
          }

      - name: Create Sentry release
        if: env.NEXT_PUBLIC_SENTRY_DSN && inputs.publishSentryRelease == 'true'
        uses: getsentry/action-release@v3
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.sentryAuthToken }}
          SENTRY_ORG: ${{ vars.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ github.event.repository.name }}
          SENTRY_URL: ${{ env.NEXT_PUBLIC_SENTRY_DSN }}
        with:
          environment: ${{ inputs.environment }}
          release: ${{ github.event.release.tag_name || github.sha }}

      - name: Get Current Date
        id: date
        shell: bash
        run: |
          # Get Current Date
          echo "date=$(date +'%m/%d/%YT%H:%M:%S')" >> $GITHUB_OUTPUT

      - name: Install PowerShell modules for Accessing Azure Table Storage
        shell: pwsh
        run: |
          Install-Module -Name AzTable,Az.Storage,Az.Resources -Force

      - name: Record deployment information in Azure Storage Table
        shell: pwsh
        env:
          storageAccountName: amucloudapps
          appInfoTableName: DeployedApplications
          repositoryName: ${{ github.event.repository.name }}
          environment: ${{ inputs.environment }}
          appName: ${{ needs.build.outputs.appName }}
          appVersion: ${{ needs.build.outputs.appVersion }}
          environmentKeyVault: ${{ inputs.environmentKeyVault }}
          dnsPrimaryDomain: ${{ steps.values-override.outputs.dnsPrimaryDomain }}
          domainName: ${{ needs.build.outputs.domainName }}
          ingress: ${{ needs.build.outputs.ingress }}
          aksIngress: ${{ steps.dns.outputs.aksIngress }}
          aksResourceGroup: ${{ steps.aks-resource-group.outputs.AKS_RESOURCE_GROUP }}
          date: ${{ steps.date.outputs.date }}
        run: |
          # Record deployment information in Azure Storage Table
          $azureClusterName = "${{ secrets.azureClusterName }}"
          $storageAccountKey = ${{ secrets.storageAccountKey }}
          $storageContext = New-AzStorageContext -StorageAccountName $env:storageAccountName -StorageAccountKey $storageAccountKey

          #Get Storage table
          try {
              $appInfoTable = (Get-AzStorageTable -Name $env:appInfoTableName -Context $storageContext -ErrorAction Stop).CloudTable
              }
          catch {
              Write-Error -Message "Error accessing cloud $env:appInfoTableName table.  Error message was: $_.Exception.Message"
              return
          }

          Add-AzTableRow `
              -Table $appInfoTable `
              -partitionKey "$env:repositoryName" `
              -RowKey "$env:environment" `
              -property @{
              "ApplicationName"="$env:appName";
              "Version"="$env:appVersion";
              "KeyVault"="$env:environmentKeyVault";
              "HostName"="$env:dnsPrimaryDomain";
              "DomainName"="$env:domainName";
              "IngressFqdn"="$env:ingress";
              "AksIngress"="$env:aksIngress";
              "Cluster"="$azureClusterName";
              "ClusterResourceGroup"="$env:aksResourceGroup";
              "LastDeploy"="$env:date"
              } -UpdateExisting | Out-Null

      - name: Create deployment summary
        shell: bash
        env:
          APP_NAME: ${{ needs.build.outputs.appName }}
          ENVIRONMENT: ${{ inputs.environment }}
          APP_VERSION: ${{ needs.build.outputs.appVersion }}
          ENVIRONMENT_KEY_VAULT: ${{ inputs.environmentKeyVault }}
          INGRESS: ${{ needs.build.outputs.ingress }}
        run: |
          echo "### ${APP_NAME} Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Application Name**: ${APP_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${APP_VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- **Key Vault Name**: ${ENVIRONMENT_KEY_VAULT}" >> $GITHUB_STEP_SUMMARY
          echo "- **FQDN**: ${INGRESS}" >> $GITHUB_STEP_SUMMARY
      - name: Send Failed Deployment report to Teams
        if: failure() && (inputs.environment != 'development')
        uses: jdcargile/ms-teams-notification@v1.4
        with:
          github-token: ${{ github.token }}
          ms-teams-webhook-uri: ${{ inputs.deploymentWebhook }}
          notification-summary: "${{ github.event.release.tag_name != '' && format('{0} ', github.event.release.tag_name) || ' ' }}Failed ${{ inputs.environment }} Deployment"
          notification-color: 17a2b8
          timezone: America/Chicago
          verbose-logging: true

      - name: Send Succeeded Deployment report to Teams
        if: success() && (inputs.environment != 'development')
        uses: jdcargile/ms-teams-notification@v1.4
        with:
          github-token: ${{ github.token }}
          ms-teams-webhook-uri: ${{ inputs.deploymentWebhook }}
          notification-summary: "${{ github.event.release.tag_name != '' && format('{0} ', github.event.release.tag_name) || ' ' }}Successful ${{ inputs.environment }} Deployment"
          notification-color: 28a745
          timezone: America/Chicago
          verbose-logging: true