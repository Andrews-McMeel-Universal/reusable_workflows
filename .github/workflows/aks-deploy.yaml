name: AKS Deployment

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: "Deploy Environment.  This is used to pull in and set the github environment. Can be development, staging, or production."
      environmentKeyVault:
        required: false
        type: string
        description: "AKS Key vault."
      repositoryName:
        required: false
        type: string
        description: "GitHub Repository Name."
        default: "${{ github.event.repository.name }}"
      clusterResourceGroup:
        required: false
        type: string
        description: "AKS Cluster Resource Group."
        default: "AMU_AKS_201"
      dnsResourceGroup:
        required: false
        type: string
        description: "DNS Resource Group."
        default: "AMU_DNS_RG"
      chartsPath:
        required: false
        type: string
        description: "Relative path to Helm charts."
        default: "./deployments/charts"
      dockerFilePath:
        required: false
        type: string
        description: "Relative path to Dockerfile."
        default: "."
      dockerImageName:
        required: false
        type: string
        description: "Docker image name."
        default: "${{ github.event.repository.name }}"
      dockerImageTag:
        required: false
        type: string
        description: "Docker image tag."
        default: "${{ github.sha }}"
      maximumReplicas:
        required: false
        type: string
        description: "Maximum number of replicas for the application HPA."
        default: 30
      storageAccountName:
        required: false
        type: string
        description: "Storage Account for application information table."
        default: "amucloudapps"
      appInfoTableName:
        required: false
        type: string
        description: "Application information storage table."
        default: "DeployedApplications"
      deploymentTimeout:
        required: false
        type: number
        description: "Timeout for GitHub deployments"
        default: 20
      webAuthentication:
        required: false
        type: string
        description: "Enable web authentication"
        default: "false"
      ingressWhitelist:
        required: false
        type: string
        description: "IPs to include in the application whitelist"
        default: "0.0.0.0/0"
      adminIngressWhitelist:
        required: false
        type: string
        description: "IPs to include in the Admin application whitelist"
        default: "207.67.20.252"
      environmentIngress:
        required: false
        type: string
        description: "Add the environment name to the front of the hostname (for DNS)"
        default: "true"
    secrets:
      azureClusterName:
        required: true
      azureCredentials:
        required: true
      registryHostName:
        required: true
      registryUserName:
        required: true
      registryPassword:
        required: true
      storageAccountKey:
        required: true
      webAuthenticationPassword:
        required: false
      webAuthenticationUsername:
        required: false

jobs:
  setup:
    name: "Prepare for build"
    runs-on: ubuntu-latest
    continue-on-error: false
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Extract Helm values
        id: setenvs
        shell: pwsh
        run: |
          Install-Module -Name powershell-yaml -Confirm:$false -Force
          Function Get-Envs {
              param (
                  [parameter(Mandatory = $true, ValueFromPipeline = $true)]
                  [string]$PathToYaml
              )
              Import-Module powershell-yaml
              Write-Host "Getting configuration from: $PathToYaml."
              $Values = Get-Content $PathToYaml | ConvertFrom-Yaml
              return $Values
          }

          $appEnvironment = "${{ inputs.environment }}"
          $basePath = Get-Location
          $valuesYamlPath = Join-Path $basePath ${{ inputs.chartsPath }} "values.yaml"
          $appConfig = Get-Envs -PathToYaml $valuesYamlPath
          $chartYamlPath = Join-Path $basePath ${{ inputs.chartsPath }} "Chart.yaml"
          $chartConfig = Get-Envs -PathToYaml $chartYamlPath

          $appName = $chartConfig.name
          $appVersion = $chartConfig.appVersion
          $appHealthCheck = $appconfig.deployment.healthCheckPath
          $configMap = $appConfig.deployment.configMap
          $configSecret = $appConfig.deployment.secret
          $imagePullSecret = "$appName-pull-secret"
          $release = "$appName-${{ github.sha }}" -replace '(^.{53})(.*$)', '$1'
          $release = ($release -replace '[^-\p{L}\p{Nd}]', '').ToLower() -replace '^-', '' -replace '-$', ''
          $ingress = $appConfig.ingress.host
          $domainName = ($ingress.Split('.') | Select-Object -Last 2) -join '.'
          $environmentIngress = "${{ inputs.environmentIngress }}" -replace '"', '' -replace "'", ""
          $hostName = $ingress -replace $domainName, '' -replace "\.$", ""
          $ingressWhitelist = $appConfig.ingress.annotations."nginx.ingress.kubernetes.io/whitelist-source-range" ?? "${{ inputs.ingressWhitelist }}"
          if ($appConfig.adminingress) {
              $adminIngressWhitelist = $appConfig.adminingress.annotations."nginx.ingress.kubernetes.io/whitelist-source-range" ?? "${{ inputs.adminIngressWhitelist }}"
              if (![bool]($adminIngressWhitelist -match "^\d{1,3}(\.\d{1,3}){3}(\/\d{1,2})?(,\d{1,3}(\.\d{1,3}){3}(\/\d{1,2})?)*$")) { 
                  Write-Output "::warning file=$valuesYamlPath::Invalid value set for 'adminingress.annotations.nginx.ingress.kubernetes.io/whitelist-source-range'. Defaulting to ${{ inputs.adminIngressWhitelist }} Value: $adminIngressWhitelist"
                  $adminIngressWhitelist = "${{ inputs.adminIngressWhitelist }}"
              }
          }
          else {
              Write-Output "::notice file=$valuesYamlPath::adminingress values not defined. Skipping setting adminIngressWhitelist"
          }

          if ($environmentIngress -eq "true") {
              $ingress = "$appEnvironment.$ingress"
              if ($hostName.Length -gt 0) {
                  $hostName = "$appEnvironment.$hostName"
              }
              else {
                  $hostName = "$appEnvironment"
              }
          }
          else {
              if ($hostName.Length -eq 0) {
                  $hostName = "www"
              }
          }
          Write-Output "::notice file=$valuesYamlPath::This application's hostname is $hostName.$domainName"

          Write-Output "appName=$appName" >> $env:GITHUB_ENV
          Write-Output "appVersion=$appVersion" >> $env:GITHUB_ENV
          Write-Output "appHealthCheck=$appHealthCheck" >> $env:GITHUB_ENV
          Write-Output "configMap=$configMap" >> $env:GITHUB_ENV
          Write-Output "configSecret=$configSecret" >> $env:GITHUB_ENV
          Write-Output "ingress=$ingress" >> $env:GITHUB_ENV
          Write-Output "domainName=$domainName" >> $env:GITHUB_ENV
          Write-Output "hostName=$hostName" >> $env:GITHUB_ENV
          Write-Output "imagePullSecret=$imagePullSecret" >> $env:GITHUB_ENV
          Write-Output "date=$(date +'%m/%d/%YT%H:%M:%S')" >> $env:GITHUB_ENV
          Write-Output "ingressWhitelist=$ingressWhitelist" >> $env:GITHUB_ENV
          Write-Output "adminIngressWhitelist=$adminIngressWhitelist" >> $env:GITHUB_ENV
          Write-Output "release=$release" >> $env:GITHUB_ENV

      - name: Login via Az module
        uses: azure/login@v1.4.7
        with:
          creds: "${{ secrets.azureCredentials }}"
          enable-AzPSSession: true

      - name: Generate .env file from Azure Key Vaults
        uses: Andrews-McMeel-Universal/get-envs@v1
        with:
          azurecredentials: ${{ secrets.azureCredentials }}
          environment: ${{ inputs.environment }}
          environmentKeyVault: ${{ inputs.environmentKeyVault }}

      - name: Set target AKS cluster
        uses: Azure/aks-set-context@v3.2
        with:
          cluster-name: ${{ secrets.azureClusterName }}
          resource-group: ${{ inputs.clusterResourceGroup }}

      - name: Switch to ${{ inputs.environment }} Namespace
        run: kubectl config set-context --current --namespace="${{ inputs.environment }}"

      - name: Apply configMap if it exists
        if: ${{ env.configMap != null }}
        uses: swdotcom/update-and-apply-kubernetes-configs@v1.2.0
        with:
          k8-config-file-paths: deployments/k8s/config-${{ inputs.environment }}.yaml

      - name: Add GitHub secrets to k8s
        shell: pwsh
        run: |
          if (kubectl get secret | Select-String "${{ env.configSecret }}") {
              kubectl delete secret "${{ env.configSecret }}"
          }
          kubectl create secret generic "${{ env.configSecret }}" --from-env-file .env

          if ( "${{ inputs.webAuthentication }}" -eq "true") {
              if (!"${{ secrets.webAuthenticationUsername }}" -or !"${{ secrets.webAuthenticationPassword }}") {
                  Write-Output "::error::Please make sure the 'webAuthenticationUsername' and 'webAuthenticationPassword' GitHub environment secrets are set correctly."
                  exit 1
              }

              if (kubectl get secret | Select-String "${{ env.appName }}-basic-auth") {
                  kubectl delete secret "${{ env.appName }}-basic-auth"
              }
              htpasswd -cb auth "${{ secrets.webAuthenticationUsername }}" "${{ secrets.webAuthenticationPassword }}"
              kubectl create secret generic "${{ env.appName }}-basic-auth" --from-file=auth
          }

      - name: Create K8s Image Pull Secret
        uses: Azure/k8s-create-secret@v4.0
        with:
          container-registry-url: ${{ secrets.registryHostName }}
          container-registry-username: ${{ secrets.registryUserName  }}
          container-registry-password: ${{ secrets.registryPassword  }}
          secret-name: "${{ env.imagePullSecret }}"

    outputs:
      appName: ${{ env.appName }}
      appVersion: ${{ env.appVersion }}
      appHealthCheck: ${{ env.appHealthCheck }}
      configMap: ${{ env.configMap }}
      configSecret: ${{ env.configSecret }}
      ingress: ${{ env.ingress }}
      domainName: ${{ env.domainName }}
      hostName: ${{ env.hostName }}
      imagePullSecret: ${{ env.imagePullSecret }}
      date: ${{ env.date }}
      ingressWhitelist: ${{ env.ingressWhitelist }}
      adminIngressWhitelist: ${{ env.adminIngressWhitelist }}
      release: ${{ env.release }}

  build:
    name: "Build Docker Image"
    runs-on: ubuntu-latest
    needs: [setup]
    continue-on-error: false
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Login via Az module
        uses: azure/login@v1.4.7
        with:
          creds: "${{ secrets.azureCredentials }}"
          enable-AzPSSession: true

      - name: Generate .env file from Azure Key Vaults
        uses: Andrews-McMeel-Universal/get-envs@v1
        with:
          azurecredentials: ${{ secrets.azureCredentials }}
          environment: ${{ inputs.environment }}
          environmentKeyVault: ${{ inputs.environmentKeyVault }}

      - name: Generate build args from Azure Key Vaults
        uses: azure/powershell@v1.2.0
        with:
          inlineScript: |
            if ("${{ inputs.environmentKeyVault }}") {
                $KeyVaultName = "${{ inputs.environmentKeyVault }}"
            }
            else {
                $KeyVaultName = (Get-AzKeyVault -Tag @{"environment" = "${{ inputs.environment }}" } | Get-AzKeyVault -Tag @{"repository-name" = "${{ github.event.repository.name }}" }).VaultName
            }
            [string]$KeyVaultName = $KeyVaultName.Replace(" ", "-")
            $buildSecrets = (Get-AzKeyVaultSecret -VaultName $KeyVaultName  | Where-Object { ($_.ContentType -contains 'BuildArg') -or ($_.ContentType -contains 'BuildArg Env') }).Name
            if ($buildSecrets.Count -gt 0) {
                $buildArgPredicate = ' --build-arg '
            }
            else {
                return
            }
            $buildSecrets | ForEach-Object {
                $argName = $_.ToUpper()
                $argName = $argName.Replace("-", "_")
                $argSecret = (Get-AzKeyVaultSecret -VaultName $KeyVaultName -Name $_).secretvalue | ConvertFrom-SecureString -AsPlainText
                $buildArguments = $buildArguments + $buildArgPredicate + $argName + "=" + $argSecret
            }

            echo "buildArguments=$buildArguments" >> $env:GITHUB_ENV
          azPSVersion: "latest"

      - name: Login to Azure Container Registry
        uses: Azure/docker-login@v1.0.1
        with:
          login-server: ${{ secrets.registryHostName }}
          username: ${{ secrets.registryUserName }}
          password: ${{ secrets.registryPassword }}

      - name: Build & Push Docker Image
        run: |
          docker build ${{ inputs.dockerFilePath }} ${{ env.buildArguments }} -t "${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}:${{ inputs.dockerImageTag }}"
          docker push "${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}:${{ inputs.dockerImageTag }}"

      - name: Create values override file
        run: |
          WEB_AUTHENTICATION=$(echo "${{ inputs.webAuthentication }}" | tr -d "'" | tr -d '"')
          INGRESS_WHITELIST="${{ needs.setup.outputs.ingressWhitelist }}"
          ADMIN_INGRESS_WHITELIST="${{ needs.setup.outputs.adminIngressWhitelist }}"
          echo "::debug::WEB_AUTHENTICATION=$WEB_AUTHENTICATION"
          echo "::debug::INGRESS_WHITELIST=$INGRESS_WHITELIST"
          echo "::debug::ADMIN_INGRESS_WHITELIST=$ADMIN_INGRESS_WHITELIST"

          if [[ "${WEB_AUTHENTICATION}" == "true" ]] ; then
            if [[ -n "${ADMIN_INGRESS_WHITELIST}" ]] ; then
              echo "::debug::WEB_AUTHENTICATION=true,ADMIN_INGRESS_WHITELIST!=null"
          cat << EOF >> values-override.yaml
          ingress:
            annotations:
              nginx.ingress.kubernetes.io/limit-whitelist: "207.67.20.252"
              nginx.ingress.kubernetes.io/whitelist-source-range: "${INGRESS_WHITELIST}"
              nginx.ingress.kubernetes.io/auth-type: "basic"
              nginx.ingress.kubernetes.io/auth-secret: "${{ needs.setup.outputs.appName }}-basic-auth"
              nginx.ingress.kubernetes.io/auth-realm: "Authentication Required"
          adminingress:
            annotations:
              nginx.ingress.kubernetes.io/whitelist-source-range: "${ADMIN_INGRESS_WHITELIST}"
          EOF
            else
              echo "::debug::WEB_AUTHENTICATION=true,ADMIN_INGRESS_WHITELIST=null"
          cat << EOF >> values-override.yaml
          ingress:
            annotations:
              nginx.ingress.kubernetes.io/limit-whitelist: "207.67.20.252"
              nginx.ingress.kubernetes.io/whitelist-source-range: "${INGRESS_WHITELIST}"
              nginx.ingress.kubernetes.io/auth-type: "basic"
              nginx.ingress.kubernetes.io/auth-secret: "${{ needs.setup.outputs.appName }}-basic-auth"
              nginx.ingress.kubernetes.io/auth-realm: "Authentication Required"
          EOF
            fi
          elif [[ -n "${ADMIN_INGRESS_WHITELIST}" ]] ; then
            echo "::debug::WEB_AUTHENTICATION=false,ADMIN_INGRESS_WHITELIST!=null"
          cat << EOF >> values-override.yaml
          ingress:
            annotations:
              nginx.ingress.kubernetes.io/limit-whitelist: "207.67.20.252"
              nginx.ingress.kubernetes.io/whitelist-source-range: "${INGRESS_WHITELIST}"
          adminingress:
            annotations:
              nginx.ingress.kubernetes.io/whitelist-source-range: "${ADMIN_INGRESS_WHITELIST}"
          EOF
          else
            echo "::debug::WEB_AUTHENTICATION=false,ADMIN_INGRESS_WHITELIST=null"
          cat << EOF >> values-override.yaml
          ingress:
            annotations:
              nginx.ingress.kubernetes.io/limit-whitelist: "207.67.20.252"
              nginx.ingress.kubernetes.io/whitelist-source-range: "${INGRESS_WHITELIST}"
          EOF
          fi

      - name: Bake Helm Templates
        id: bake
        uses: azure/k8s-bake@v2.4
        with:
          renderEngine: "helm"
          helmChart: ${{ inputs.chartsPath }}
          releaseName: ${{ needs.setup.outputs.release }}
          helm-version: "latest"
          overrideFiles: ./values-override.yaml
          overrides: |
            image.repository:${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}
            image.tag:${{ inputs.dockerImageTag }}
            ingress.host:${{ needs.setup.outputs.ingress }}
            autoscaling.maxReplicas:${{ inputs.maximumReplicas }}

      - name: Upload bake-manifests-bundle artifact
        uses: actions/upload-artifact@v3
        with:
          name: bake-manifests-bundle
          path: ${{ steps.bake.outputs.manifestsBundle }}
          retention-days: 1

    outputs:
      manifestsBundle: ${{ steps.bake.outputs.manifestsBundle }}

  deploy:
    name: "Deploy to AKS cluster"
    needs: [setup, build]
    runs-on: ubuntu-latest
    continue-on-error: false
    environment:
      name: ${{ inputs.environment }}
      url: ${{ needs.setup.outputs.ingress }}
    steps:
      - name: Download bake-manifests-bundle artifact
        uses: actions/download-artifact@v3
        with:
          name: bake-manifests-bundle
          path: ${{ needs.build.outputs.manifestsBundle }}

      - name: Login via Az module
        uses: azure/login@v1.4.7
        with:
          creds: "${{ secrets.azureCredentials }}"

      - name: Set target AKS cluster
        uses: Azure/aks-set-context@v3.2
        with:
          cluster-name: ${{ secrets.azureClusterName }}
          resource-group: ${{ inputs.clusterResourceGroup }}

      - name: Deploy to Azure Kubernetes Service
        timeout-minutes: ${{ inputs.deploymentTimeout }}
        uses: Azure/k8s-deploy@v4.9
        with:
          namespace: ${{ inputs.environment }}
          manifests: ${{ needs.build.outputs.manifestsBundle }}
          images: |
            "${{ secrets.registryHostName }}/${{ inputs.dockerImageName }}:${{ inputs.dockerImageTag }}"
          imagePullSecrets: |
            "${{ needs.setup.outputs.imagePullSecret }}"
          pull-images: false

  update-records:
    name: Update deployment records
    needs: [setup, build, deploy]
    runs-on: ubuntu-latest
    continue-on-error: false
    steps:
      - name: Login via Az module
        uses: azure/login@v1.4.7
        with:
          creds: "${{ secrets.azureCredentials }}"
          enable-AzPSSession: true

      - name: Create or Update Public DNS Record
        uses: azure/powershell@v1.2.0
        with:
          inlineScript: |
            $NewRecords = New-AzDnsRecordConfig -Cname "${{ secrets.azureClusterName }}-${{ inputs.environment }}-ingress.centralus.cloudapp.azure.com."

            New-AzDnsRecordSet -Name "${{ needs.setup.outputs.hostName }}" -RecordType CNAME -ZoneName "${{ needs.setup.outputs.domainName }}" -ResourceGroupName ${{ inputs.dnsResourceGroup }} -Ttl 3600 -DnsRecords $NewRecords -Overwrite;
          azPSVersion: "latest"

      - name: Record deployment information in Azure Storage Table
        uses: LadyCailin/azure-table-storage-upload@v1.0.1
        with:
          table_name: "${{ inputs.appInfoTableName }}"
          partition_key: "${{ inputs.repositoryName }}"
          row_key: "${{ inputs.environment }}"
          data: "ApplicationName=${{ needs.setup.outputs.appName }} Version=${{ needs.setup.outputs.appVersion }} KeyVault=${{ inputs.environmentKeyVault }} HostName=${{ needs.setup.outputs.hostName }} DomainName=${{ needs.setup.outputs.domainName }} IngressFqdn=${{ needs.setup.outputs.ingress }} HealthCheckPath=${{ needs.setup.outputs.appHealthCheck }} AksIngress=${{ secrets.azureClusterName }}-${{ inputs.environment }}-ingress.centralus.cloudapp.azure.com. Cluster=${{ secrets.azureClusterName }} ClusterResourceGroup=${{ inputs.clusterResourceGroup }} ConfigSecret=${{needs.setup.outputs.configSecret }} ConfigMap=${{ needs.setup.outputs.configMap }} LastDeploy=${{ needs.setup.outputs.date }}"
          if_exists: "replace"
          extra_args: ""
          connection_string: "AccountName=${{ inputs.storageAccountName }};AccountKey=${{ secrets.storageAccountKey }}"

      - name: Create deployment summary
        run: |
          echo "### ${{ needs.setup.outputs.appName }} Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Application Name**: ${{ needs.setup.outputs.appName }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.setup.outputs.appVersion }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Key Vault Name**: ${{ inputs.environmentKeyVault }}" >> $GITHUB_STEP_SUMMARY
          echo "- **FQDN**: ${{ needs.setup.outputs.ingress }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: ${{ secrets.azureClusterName }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ConfigSecret**: ${{ needs.setup.outputs.configSecret }}" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ needs.setup.outputs.configMap }}" ]] ; then
            echo "- **ConfigMap**: ${{ needs.setup.outputs.configMap }}" >> $GITHUB_STEP_SUMMARY
          fi
