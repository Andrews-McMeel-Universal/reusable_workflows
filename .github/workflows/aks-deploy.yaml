on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: "Deploy environment. Can be development, staging, or production."
      charts_path:
        required: true
        type: string
        description: "Relative path to Helm charts."
      docker_image_name:
        required: true
        type: string
        description: "Name for docker image."
      docker_image_tag:
        required: true
        type: string
        description: "Name for docker image tag."
      dockerfile_path:
        required: true
        type: string
        description: "Relative path to Dockerfile."
      application_maximum_replicas:
        required: false
        type: string
        description: "Maximum number of replicas for the application HPA."
        default: 4
    secrets:
      azure_credentials:
        required: true
      registry_username:
        required: true
      registry_password:
        required: true
         
      
jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - id: getlatestrelease
        uses: thebritican/fetch-latest-release@v1.0.3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout if Staging or Development deployment.
        if: ${{ inputs.environment != 'production'}}
        uses: actions/checkout@master

      - name: Checkout Latest release if Production deployment.
        if: ${{ inputs.environment == 'production'}}
        uses: actions/checkout@v2
        with: 
          ref: ${{ steps.getlatestrelease.outputs.tag_name }}

      - name: Get Env
        id: getenvs
        shell: pwsh
        run: |
          function Get-Envs {
            param (
                  [parameter(Mandatory = $true, ValueFromPipeline = $true)]
                  [string]$PathToYaml
                  )

                  #Check to see if powershell-yaml is installed 
                  if (Get-Module -Name powershell-yaml) {
                    #It's installed, this would be if you are running locally. 
                  }
                  else {
                      Write-Host "Installing Powershell-Yaml."
                      Install-Module -Name powershell-yaml -Confirm:$false -Force
                  }

                  Import-Module powershell-yaml

                  Write-Host "Getting configuration from: $PathToYaml."

                  $Values = Get-Content $PathToYaml | ConvertFrom-Yaml

                  return $Values
          }

          function Get-AzureEnvironment {
                  param (
                  [parameter(Mandatory = $true, ValueFromPipeline = $true)]
                  [string]$EnvironmentUri,
                  [parameter(Mandatory = $true, ValueFromPipeline = $true)]
                  [string]$Sas
                  )

                  #Check to see if powershell-yaml is installed 
                  if (Get-Module -Name powershell-yaml) {
                    #It's installed, this would be if you are running locally. 
                  }
                  else {
                      Write-Host "Installing Powershell-Yaml."
                      Install-Module -Name powershell-yaml -Confirm:$false -Force
                  }

                  Import-Module powershell-yaml

                  Write-Host "Getting Azure configuration from: $EnvironmentUri."

                  $FullUri = $EnvironmentUri + $Sas
                  Invoke-WebRequest -Uri $FullUri -OutFile azureconfig.yaml

                  $Values = Get-Content ./azureconfig.yaml | ConvertFrom-Yaml

                  return $Values
          }
          
          #Get Application Env Info
          $AppEnv = "${{ inputs.environment }}"
          $BasePath = Get-Location
          $YamlPath = Join-Path $BasePath ${{ inputs.charts_path }} "values.yaml"
          $AppConfig = Get-Envs -PathToYaml $YamlPath
          $YamlPath = Join-Path $BasePath ${{ inputs.charts_path }} "Chart.yaml"
          $ChartConfig = Get-Envs -PathToYaml $YamlPath
          $AppName = $ChartConfig.name
          $ConfigMap = $AppConfig.deployment.configMap
          $ConfigSecret = $AppConfig.deployment.secret
          $Ingress = $AppConfig.ingress.host
          $DomainName = ($Ingress.Split('.') | Select-Object -Last 2) -join '.'
          $HostName = $Ingress -replace $DomainName, ''
          $HostName = $HostName.Substring(0,$HostName.Length-1)
          switch ($AppEnv) {
            'development' {$HostName = "development.$Hostname"; $Ingress = "development.$Ingress"}
            'staging' {$HostName = "staging.$Hostname"; $Ingress = "staging.$Ingress"}
          }
          $ImagePullSecret = "$AppName-pull-secret"

          #Get Azure Env Info
          $AzureConfig = Get-AzureEnvironment -EnvironmentUri '${{ inputs.environment_uri }}' -Sas '${{ secrets.sas }}'
          $ApiManagementService = $AzureConfig.api.name
          $ApiManagementResourceGroup = $AzureConfig.api.resourceGroup
          $ApiSubscriptionSecretName = $AzureConfig.api.subscriptionIdSecret
          $AksCluster = $AzureConfig.cluster.name
          $AksNameSpace = $AzureConfig.cluster.nameSpace
          $AksResourceGroup = $AzureConfig.cluster.resourceGroup
          $AksContainerRegistry = $AzureConfig.cluster.containerRegistry
          $AksIngress = $AzureConfig.cluster.ingress
          $DatabaseServer = $AzureConfig.database.postgresql.name
          $DatabaseResourceGroup = $AzureConfig.database.postgresql.resourceGroup
          $DatabaseFqdn = $AzureConfig.database.postgresql.fqdn
          $DnsResourceGroup = $AzureConfig.dns.resourceGroup
          $RedisName = $AzureConfig.redis.name
          $RedisResourceGroup = $AzureConfig.redis.resourceGroup
          $RedisFqdn = $AzureConfig.redis.fqdn

          echo "::set-output name=APPNAME::$AppName"
          echo "::set-output name=CONFIGMAP::$ConfigMap"
          echo "::set-output name=CONFIGSECRET::$ConfigSecret"
          echo "::set-output name=APPINGRESS::$Ingress"
          echo "::set-output name=DOMAINNAME::$DomainName"
          echo "::set-output name=HOSTNAME::$HostName"
          echo "::set-output name=IMAGEPULLSECRET::$ImagePullSecret"
          echo "::set-output name=APIMANAGEMENTSERVICE::$ApiManagementService"
          echo "::set-output name=APIMANAGEMENTRESOURCEGROUP::$ApiManagementResourceGroup" 
          echo "::set-output name=APIMANAGEMENTSECRETNAME::$ApiManagementSecretName"
          echo "::set-output name=AKSCLUSTER::$AksCluster"
          echo "::set-output name=AKSCONTAINERREGISTRY::$AksContainerRegistry"
          echo "::set-output name=AKSINGRESS::$AksIngress"
          echo "::set-output name=AKSNAMESPACE::$AksNameSpace"
          echo "::set-output name=AKSRESOURCEGROUP::$AksResourceGroup"
          echo "::set-output name=DATABASESERVER::$DatabaseServer"
          echo "::set-output name=DATABASEFQDN::$DatabaseFqdn"
          echo "::set-output name=DATABASERESOURCEGROUP::$DatabaseResourceGroup"
          echo "::set-output name=REDISNAME::$RedisName"
          echo "::set-output name=REDISRESOURCEGROUP::$RedisResourceGroup"
          echo "::set-output name=REDISFQDN::$REDISFqdn"
          


      - name: Login via Az module
        uses: azure/login@v1
        with:
          creds: '${{ secrets.azure_credentials }}'
          enable-AzPSSession: true

      - name: Login to Azure Container Registry
        uses: Azure/docker-login@v1
        with:
          login-server: ${{ inputs.container_registry }}
          username: ${{ secrets.registry_username }}
          password: ${{ secrets.registry_password }}
      
      - name: Set target AKS cluster
        uses: Azure/aks-set-context@v1
        with:
          creds: '${{ secrets.azure_credentials }}'
          cluster-name: ${{ inputs.aks_cluster_name }}
          resource-group: ${{ inputs.aks_cluster_rg }}

      - name: Switch to Deployment Namespace
        run: kubectl config set-context --current --namespace=${{ steps.getenvs.outputs.AKSNAMESPACE }}
      
      - name: Apply ConfigMap
        if: ${{ steps.getenvs.outputs.CONFIGMAP != null }}
        uses: swdotcom/update-and-apply-kubernetes-configs@v1
        with:
          k8-config-file-paths: deployments/k8s/config-${{ steps.getenvs.outputs.AKSNAMESPACE }}.yaml
      
      - name: Add GitHub secrets to k8s
        if: ${{ steps.getenvs.outputs.CONFIGSECRET != null }}
        uses: Azure/k8s-create-secret@v1
        with:
          namespace: ${{ steps.getenvs.outputs.AKSNAMESPACE }}
          secret-type: 'generic'
          arguments: '--from-literal=${{ inputs.secret_key1 }}=${{ secrets.secret_value1 }}'
          secret-name: ${{ steps.getenvs.outputs.CONFIGSECRET }}

      - name: Create or Update Public DNS Record
        uses: azure/powershell@v1
        with:
          inlineScript: |
            $NewRecords = New-AzDnsRecordConfig -Cname ${{ steps.getenvs.outputs.AKSINGRESS }};
            New-AzDnsRecordSet -Name "${{ steps.getenvs.outputs.HOSTNAME  }}" -RecordType CNAME -ZoneName ${{ steps.getenvs.outputs.DOMAINNAME  }} -ResourceGroupName ${{ inputs.dns_rg }} -Ttl 3600 -DnsRecords $NewRecords -Overwrite;
          azPSVersion: '3.1.0'

      - name: Create k8s Image Pull Secret
        uses: Azure/k8s-create-secret@v1
        with:
          container-registry-url: ${{ steps.getenvs.outputs.AKSCONTAINERREGISTRY }}
          container-registry-username: ${{ secrets.registry_username }}
          container-registry-password: ${{ secrets.registry_password }}
          secret-name: ${{ steps.getenvs.outputs.IMAGEPULLSECRET }}

      - name: Build & Push Docker Image
        run: |
          docker build ${{ inputs.dockerfile_path }}  -t ${{ steps.getenvs.outputs.AKSCONTAINERREGISTRY }}/${{ inputs.docker_image_name }}:${{ inputs.docker_image_tag }}
          docker push ${{ steps.getenvs.outputs.AKSCONTAINERREGISTRY }}/${{ inputs.docker_image_name }}:${{ inputs.docker_image_tag }}

      
      - name: Create valid release-name
        id: generate-release-name
        run: |
          release=${{ inputs.docker_image_name }}-${{ inputs.docker_image_tag }}
          release=${release::53}
          release=$(echo ${release//[!0-9a-zA-Z]/-} | tr '[:upper:]' '[:lower:]' | sed -e 's/^-/z/' -e 's/-$/z/')
          echo ::set-output name=result::$release

      - name: Bake Helm templates
        uses: azure/k8s-bake@v1
        with:
          renderEngine: 'helm'
          helmChart: ${{ inputs.charts_path }}
          releaseName: ${{steps.generate-release-name.outputs.result}}
          helm-version: 'latest'
          overrides: |
            image.repository:${{ steps.getenvs.outputs.AKSCONTAINERREGISTRY }}/${{ inputs.docker_image_name }}
            image.tag:${{ inputs.docker_image_tag }}
            ingress.host:${{ steps.getenvs.outputs.APPINGRESS }}
            autoscaling.maxReplicas:${{ inputs.application_maximum_replicas }}
        id: bake

      - name: Deploy to Azure
        uses: Azure/k8s-deploy@v1
        with:
          namespace: ${{ steps.getenvs.outputs.AKSNAMESPACE }}
          manifests: ${{ steps.bake.outputs.manifestsBundle }}
          images: |
            ${{ steps.getenvs.outputs.AKSCONTAINERREGISTRY }}/${{ inputs.docker_image_name }}:${{ inputs.docker_image_tag }}
          imagepullsecrets: |
            ${{ steps.getenvs.outputs.IMAGEPULLSECRET }}
    outputs:
      environment: ${{ inputs.environment }}
      hostName: ${{ steps.getenvs.outputs.HOSTNAME }}
      domainName: ${{ steps.getenvs.outputs.DOMAINNAME }}
      ingress_fqdn: ${{ steps.getenvs.outputs.APPINGRESS }}
      aks_ingress_fqdn: ${{ inputs.aks_ingress_fqdn }}

