name: Clear Azure Redis Cache

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: "Environment to clear caches for."
      resourceGroupName:
        default: "AMU_DevOps_RG"
        type: string
        description: "Name of Resource Group that the Azure Redis Instance is in."
      applicationCacheKey:
        default: ${{ vars.REDIS_CACHE_KEY || '*' }}
        type: string
        description: "Cache key for the application"
    secrets:
      azureCredentials:
       required: true

jobs:
  clear-redis-cache:
    name: Clear Azure Redis Cache
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login via Az module
        uses: azure/login@v2
        with:
          creds: "${{ secrets.azureCredentials }}"
          enable-AzPSSession: true

      - name: Install redis-tools apt package
        run: sudo apt-get update -y && sudo apt-get install redis-tools -y

      - name: Install PowerShell modules
        shell: pwsh
        run: |
          Install-Module -Name Az.RedisCache -Force

      # Script is adapted from https://github.com/Andrews-McMeel-Universal/azure-content-management_tool/blob/main/Scripts/rundeck/Flush-RedisCache.ps1
      - name: Clear Redis Cache
        shell: pwsh
        run: |
          $CacheKeys = "${{ inputs.applicationCacheKey }}"
          $ResourceGroupName = "${{ inputs.resourceGroupName }}"
          $Environment = "${{ inputs.environment }}"
          $ScanCount = 1000
          $BatchSize = 500
          $UseUnlink = $false

          # Get list of Redis instances using tags
          $Redis = Get-AzRedisCache -ResourceGroupName "$ResourceGroupName" | Where-Object { $_.Tag.Values -eq "$Environment" }

          # Loop through Redis instances
          $Redis | ForEach-Object {
              $RedisHostname = $_.HostName
              $RedisPort = $_.Port
              $RedisName = $_.Name
              $RedisKey = (Get-AzRedisCacheKey -Name $RedisName -ResourceGroupName $ResourceGroupName).PrimaryKey

              Write-Host "Authenticating to $RedisHostname..." -ForegroundColor DarkGray

              # Loop through cache keys
              foreach ($Key in $CacheKeys.Split(',')) {
                  $Lua = @"
                      redis.replicate_commands()

                      local pattern   = ARGV[1]
                      local count     = tonumber(ARGV[2]) or 1000
                      local batchSize = tonumber(ARGV[3]) or 500
                      local useUnlink = (ARGV[4] == "1")

                      local cursor = "0"
                      local total = 0

                      repeat
                      local res   = redis.call("SCAN", cursor, "MATCH", pattern, "COUNT", count)
                      cursor      = res[1]
                      local keys  = res[2]
                      local n     = #keys

                      if n > 0 then
                          for i = 1, n, batchSize do
                          local slice = {}
                          local jmax = math.min(i + batchSize - 1, n)
                          for j = i, jmax do
                              slice[#slice + 1] = keys[j]
                          end
                          if useUnlink then
                              redis.call("UNLINK", unpack(slice))
                          else
                              redis.call("DEL", unpack(slice))
                          end
                          total = total + #slice
                          end
                      end
                      until cursor == "0"

                      return total
          "@

                  $deleted = & redis-cli `
                  -h $RedisHostname -p $RedisPort -a $RedisKey `
                  EVAL $Lua 0 $Key $ScanCount $BatchSize ($(if ($UseUnlink) {"1"} else {"0"}))

                  if ($LASTEXITCODE -ne 0) {
                      Write-Error "Error executing Redis command."
                      exit $LASTEXITCODE
                  }
                  elseif ($deleted -eq 0) {
                      Write-Host "No keys matched pattern '$Key'."
                  }
                  elseif (($deleted -is [int]) -or ($deleted -match '^\d+$')) {
                      Write-Host "Deleted $deleted keys matching pattern '$Key'."
                  }
                  else {
                      Write-Host "Unexpected result: $deleted"
                  }
              }
          }

